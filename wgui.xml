This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.zed/
  settings.json
docs/
  lsp.md
  wui.md
examples/
  allcomponents/
    src/
      cutecat.jpg
      main.rs
    Cargo.toml
  axum/
    src/
      main.rs
    Cargo.toml
  todo/
    src/
      main.rs
    Cargo.toml
  todo_wui/
    src/
      generated/
        mod.rs
        routes.gen.rs
        todo_gen.rs
        todo.gen.rs
      main.rs
    wui/
      pages/
        todo.wui
    build.rs
    Cargo.toml
ts/
  app.ts
  debouncer.ts
  message_sender.ts
  path.ts
  render.ts
  types.ts
  ws.ts
wgui/
  src/
    bin/
      wui_gen.rs
    wui/
      compiler/
        codegen.rs
        ir.rs
        lower.rs
        mod.rs
        registry.rs
        validate.rs
      ast.rs
      diagnostic.rs
      expr.rs
      mod.rs
      parser.rs
      runtime.rs
    axum.rs
    diff.rs
    dist.rs
    edit_distance.rs
    gui.rs
    lib.rs
    server.rs
    ssr.rs
    types.rs
    ui_client.rs
    ws.rs
  Cargo.toml
wui-lsp/
  src/
    main.rs
  Cargo.toml
.editorconfig
.gitignore
AGENTS.md
bundle_watch.bat
bundle_watch.sh
Cargo.toml
readme.md
rustfmt.toml
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".zed/settings.json">
{
  "file_types": {
    "WUI": ["wui"]
  },
  "languages": {
    "WUI": {
      "language_servers": ["wui-lsp"]
    }
  },
  "lsp": {
    "wui-lsp": {
      "binary": {
        "path": "target/debug/wui-lsp",
        "arguments": ["--stdio"]
      }
    }
  }
}
</file>

<file path="docs/lsp.md">
# WUI Language Server (wui-lsp)

This project includes an LSP server for `.wui` files that runs over `--stdio`.
It provides diagnostics, basic completions, hover, go-to-definition, and rename for action strings.

## Build

From the repo root:

```
cargo build -p wui-lsp
```

This builds `target/debug/wui-lsp`.
Use `cargo build -p wui-lsp --release` for a release binary.

## Zed configuration

Add to your Zed settings (User or Workspace):

```json
{
  "file_types": {
    "WUI": ["wui"]
  },
  "languages": {
    "WUI": {
      "language_servers": ["wui-lsp"],
      "file_extensions": ["wui"]
    }
  },
  "language_servers": {
    "wui-lsp": {
      "command": "target/debug/wui-lsp",
      "args": ["--stdio"]
    }
  }
}
```

For a release binary, change `command` to `target/release/wui-lsp`.

## VSCode configuration

For VSCode, configure a custom language server via your extension or a launch config.
At minimum, the server command is:

```
/path/to/wui-lsp --stdio
```

## Notes

- Logs go to stderr. Use `RUST_LOG=info` to enable logging.
- The server currently re-parses the full file on each change.
</file>

<file path="wui-lsp/src/main.rs">
use anyhow::Result;
use ropey::Rope;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tower_lsp::jsonrpc::Result as LspResult;
use tower_lsp::lsp_types::*;
use tower_lsp::{Client, LanguageServer, LspService, Server};
use tracing::info;

use wgui::wui::ast::{AttrValue, Element, Node};
use wgui::wui::compiler::registry::{schema_for, PropKind, ValueType};
use wgui::wui::diagnostic::{Diagnostic as WuiDiagnostic, Span};

#[derive(Debug, Clone)]
struct Document {
	text: Rope,
	version: i32,
}

#[derive(Default)]
struct AppState {
	documents: HashMap<Url, Document>,
}

struct Backend {
	client: Client,
	state: Arc<RwLock<AppState>>,
}

#[derive(Debug, Clone)]
struct ActionRef {
	name: String,
	span: Span,
}

#[tower_lsp::async_trait]
impl LanguageServer for Backend {
	async fn initialize(&self, params: InitializeParams) -> LspResult<InitializeResult> {
		let capabilities = ServerCapabilities {
			text_document_sync: Some(TextDocumentSyncCapability::Kind(
				TextDocumentSyncKind::FULL,
			)),
			diagnostic_provider: Some(DiagnosticServerCapabilities::Options(
				DiagnosticOptions {
					identifier: Some("wui".to_string()),
					inter_file_dependencies: false,
					workspace_diagnostics: false,
					work_done_progress_options: Default::default(),
				},
			)),
			completion_provider: Some(CompletionOptions {
				resolve_provider: Some(false),
				trigger_characters: Some(vec![
					"<".to_string(),
					" ".to_string(),
					"\"".to_string(),
					"{".to_string(),
					":".to_string(),
					"/".to_string(),
				]),
				..Default::default()
			}),
			hover_provider: Some(HoverProviderCapability::Simple(true)),
			definition_provider: Some(OneOf::Left(true)),
			rename_provider: Some(OneOf::Left(true)),
			..Default::default()
		};

		let _ = params;
		Ok(InitializeResult {
			capabilities,
			server_info: Some(ServerInfo {
				name: "wui-lsp".to_string(),
				version: Some("0.1.0".to_string()),
			}),
		})
	}

	async fn initialized(&self, _: InitializedParams) {
		info!("wui-lsp initialized");
	}

	async fn shutdown(&self) -> LspResult<()> {
		Ok(())
	}

	async fn did_open(&self, params: DidOpenTextDocumentParams) {
		let doc = params.text_document;
		let mut state = self.state.write().await;
		state.documents.insert(
			doc.uri.clone(),
			Document {
				text: Rope::from_str(&doc.text),
				version: doc.version,
			},
		);
		drop(state);

		self.publish_diagnostics(&doc.uri).await;
	}

	async fn did_change(&self, params: DidChangeTextDocumentParams) {
		let mut state = self.state.write().await;
		if let Some(doc) = state.documents.get_mut(&params.text_document.uri) {
			if let Some(change) = params.content_changes.last() {
				doc.text = Rope::from_str(&change.text);
				doc.version = params.text_document.version;
			}
		}
		drop(state);

		self.publish_diagnostics(&params.text_document.uri).await;
	}

	async fn did_close(&self, params: DidCloseTextDocumentParams) {
		let mut state = self.state.write().await;
		state.documents.remove(&params.text_document.uri);
		drop(state);

		self.client
			.publish_diagnostics(params.text_document.uri, Vec::new(), None)
			.await;
	}

	async fn completion(&self, params: CompletionParams) -> LspResult<Option<CompletionResponse>> {
		let uri = params.text_document_position.text_document.uri;
		let position = params.text_document_position.position;
		let text = self.get_text(&uri).await?;
		let offset = position_to_offset(&text, position);
		let actions = collect_actions(&text);

		let items = completion_items(&text, offset, &actions);
		Ok(Some(CompletionResponse::Array(items)))
	}

	async fn hover(&self, params: HoverParams) -> LspResult<Option<Hover>> {
		let position = params.text_document_position_params.position;
		let uri = params.text_document_position_params.text_document.uri;
		let text = self.get_text(&uri).await?;
		let offset = position_to_offset(&text, position);
		let hover = hover_info(&text, offset);
		Ok(hover)
	}

	async fn goto_definition(
		&self,
		params: GotoDefinitionParams,
	) -> LspResult<Option<GotoDefinitionResponse>> {
		let uri = params.text_document_position_params.text_document.uri;
		let position = params.text_document_position_params.position;
		let text = self.get_text(&uri).await?;
		let offset = position_to_offset(&text, position);
		let actions = collect_actions(&text);
		let Some(name) = action_at_offset(&actions, offset) else {
			return Ok(None);
		};
		let Some(target) = actions.iter().find(|a| a.name == name) else {
			return Ok(None);
		};
		let range = span_to_range(&text, target.span.start, target.span.end);
		Ok(Some(GotoDefinitionResponse::Scalar(Location {
			uri,
			range,
		})))
	}

	async fn rename(&self, params: RenameParams) -> LspResult<Option<WorkspaceEdit>> {
		let uri = params.text_document_position.text_document.uri;
		let position = params.text_document_position.position;
		let new_name = params.new_name;
		let text = self.get_text(&uri).await?;
		let offset = position_to_offset(&text, position);
		let actions = collect_actions(&text);
		let Some(name) = action_at_offset(&actions, offset) else {
			return Ok(None);
		};

		let edits = actions
			.iter()
			.filter(|action| action.name == name)
			.map(|action| TextEdit {
				range: span_to_range(&text, action.span.start, action.span.end),
				new_text: new_name.clone(),
			})
			.collect::<Vec<_>>();

		if edits.is_empty() {
			return Ok(None);
		}

		let mut changes = HashMap::new();
		changes.insert(uri, edits);
		Ok(Some(WorkspaceEdit {
			changes: Some(changes),
			document_changes: None,
			change_annotations: None,
		}))
	}
}

impl Backend {
	async fn publish_diagnostics(&self, uri: &Url) {
		let (text, version) = {
			let state = self.state.read().await;
			match state.documents.get(uri) {
				Some(doc) => (doc.text.to_string(), doc.version),
				None => return,
			}
		};

		let diagnostics = analyze(&text)
			.into_iter()
			.map(|diag| to_lsp_diagnostic(&text, diag))
			.collect::<Vec<_>>();

		self.client
			.publish_diagnostics(uri.clone(), diagnostics, Some(version))
			.await;
	}

	async fn get_text(&self, uri: &Url) -> LspResult<String> {
		let state = self.state.read().await;
		match state.documents.get(uri) {
			Some(doc) => Ok(doc.text.to_string()),
			None => Ok(String::new()),
		}
	}
}

fn analyze(text: &str) -> Vec<WuiDiagnostic> {
	let parsed = wgui::wui::parser::Parser::new(text).parse();
	let mut diags = parsed.diagnostics;
	let validated = wgui::wui::compiler::validate::validate(&parsed.nodes, &mut diags);
	if validated.is_none() {
		return diags;
	}
	let _ = wgui::wui::compiler::lower::lower(
		validated.as_ref().unwrap(),
		"main",
		&mut diags,
	);
	diags
}

fn to_lsp_diagnostic(text: &str, diag: WuiDiagnostic) -> Diagnostic {
	Diagnostic {
		range: span_to_range(text, diag.span.start, diag.span.end),
		severity: Some(DiagnosticSeverity::ERROR),
		source: Some("wui".to_string()),
		message: diag.message,
		..Default::default()
	}
}

fn completion_items(text: &str, offset: usize, actions: &[ActionRef]) -> Vec<CompletionItem> {
	let mut items = Vec::new();
	if is_in_expr(text, offset) {
		items.extend(expr_completions());
	}

	if let Some(tag_ctx) = tag_context(text, offset) {
		match tag_ctx {
			TagContext::TagName => {
				items.extend(tag_completions());
			}
			TagContext::AttrName { tag } => {
				items.extend(prop_completions(&tag));
			}
			TagContext::ActionValue => {
				items.extend(action_completions(actions));
			}
		}
	}

	items
}

fn hover_info(text: &str, offset: usize) -> Option<Hover> {
	let (start, end, word) = word_at(text, offset)?;
	if let Some(tag_ctx) = tag_context(text, offset) {
		match tag_ctx {
			TagContext::TagName => {
				let content = format!("<{}>", word);
				return Some(Hover {
					contents: HoverContents::Scalar(MarkedString::String(content)),
					range: Some(span_to_range(text, start, end)),
				});
			}
			TagContext::AttrName { tag } => {
				if let Some(info) = prop_hover(&tag, &word) {
					return Some(Hover {
						contents: HoverContents::Scalar(MarkedString::String(info)),
						range: Some(span_to_range(text, start, end)),
					});
				}
			}
			TagContext::ActionValue => {
				let content = format!("Action: {}", word);
				return Some(Hover {
					contents: HoverContents::Scalar(MarkedString::String(content)),
					range: Some(span_to_range(text, start, end)),
				});
			}
		}
	}
	None
}

fn prop_hover(tag: &str, prop: &str) -> Option<String> {
	if let Some(schema) = schema_for(tag) {
		for def in schema.props {
			if def.name == prop {
				return Some(format!("{}: {}", def.name, prop_type_name(&def.kind)));
			}
		}
	}
	if let Some(prop_type) = structural_prop_type(tag, prop) {
		return Some(format!("{}: {}", prop, prop_type));
	}
	None
}

fn prop_type_name(kind: &PropKind) -> &'static str {
	match kind {
		PropKind::Value(ValueType::String) => "string",
		PropKind::Value(ValueType::Number) => "number",
		PropKind::Value(ValueType::Bool) => "bool",
		PropKind::Event(_) => "action",
		PropKind::Bind(ValueType::String) => "bind:string",
		PropKind::Bind(ValueType::Number) => "bind:number",
		PropKind::Bind(ValueType::Bool) => "bind:bool",
	}
}

fn structural_prop_type(tag: &str, prop: &str) -> Option<&'static str> {
	match tag {
		"For" => match prop {
			"each" => Some("expr"),
			"itemAs" => Some("string"),
			"indexAs" => Some("string"),
			"key" => Some("expr"),
			_ => None,
		},
		"If" => match prop {
			"test" => Some("expr"),
			_ => None,
		},
		"Scope" => match prop {
			"name" => Some("string"),
			_ => None,
		},
		"Page" => match prop {
			"route" => Some("string"),
			"title" => Some("string"),
			"state" => Some("string"),
			_ => None,
		},
		_ => None,
	}
}

fn tag_completions() -> Vec<CompletionItem> {
	let mut items = Vec::new();
	for tag in all_tags() {
		items.push(CompletionItem {
			label: tag.to_string(),
			kind: Some(CompletionItemKind::CLASS),
			..Default::default()
		});
	}
	items
}

fn prop_completions(tag: &str) -> Vec<CompletionItem> {
	let mut items = Vec::new();
	if let Some(schema) = schema_for(tag) {
		for prop in schema.props {
			items.push(CompletionItem {
				label: prop.name.to_string(),
				kind: Some(CompletionItemKind::PROPERTY),
				..Default::default()
			});
		}
	}
	for prop in structural_props(tag) {
		items.push(CompletionItem {
			label: prop.to_string(),
			kind: Some(CompletionItemKind::PROPERTY),
			..Default::default()
		});
	}
	items
}

fn action_completions(actions: &[ActionRef]) -> Vec<CompletionItem> {
	let mut items = Vec::new();
	let mut seen = HashMap::new();
	for action in actions {
		if seen.insert(action.name.clone(), ()).is_some() {
			continue;
		}
		items.push(CompletionItem {
			label: action.name.clone(),
			kind: Some(CompletionItemKind::FUNCTION),
			..Default::default()
		});
	}
	items
}

fn expr_completions() -> Vec<CompletionItem> {
	let labels = [
		"state",
		"item",
		"true",
		"false",
		"null",
		"len(",
		"trim(",
		"lower(",
		"upper(",
	];
	labels
		.iter()
		.map(|label| CompletionItem {
			label: label.to_string(),
			kind: Some(CompletionItemKind::KEYWORD),
			..Default::default()
		})
		.collect()
}

fn collect_actions(text: &str) -> Vec<ActionRef> {
	let parsed = wgui::wui::parser::Parser::new(text).parse();
	let mut out = Vec::new();
	for node in &parsed.nodes {
		collect_actions_from_node(node, &mut out);
	}
	out
}

fn collect_actions_from_node(node: &Node, out: &mut Vec<ActionRef>) {
	if let Node::Element(el) = node {
		collect_actions_from_element(el, out);
		for child in &el.children {
			collect_actions_from_node(child, out);
		}
	}
}

fn collect_actions_from_element(el: &Element, out: &mut Vec<ActionRef>) {
	for attr in &el.attrs {
		if is_event_prop(&attr.name) {
			if let AttrValue::String(name, span) = &attr.value {
				out.push(ActionRef {
					name: name.clone(),
					span: *span,
				});
			}
		}
	}
}

fn action_at_offset(actions: &[ActionRef], offset: usize) -> Option<String> {
	for action in actions {
		if offset >= action.span.start && offset <= action.span.end {
			return Some(action.name.clone());
		}
	}
	None
}

fn is_event_prop(name: &str) -> bool {
	matches!(name, "onClick" | "onTextChanged" | "onSliderChange" | "onSelect")
}

fn is_ident_char(ch: char) -> bool {
	ch.is_ascii_alphanumeric() || ch == '_' || ch == ':' || ch == '-'
}

fn word_at(text: &str, offset: usize) -> Option<(usize, usize, String)> {
	if text.is_empty() {
		return None;
	}
	let bytes = text.as_bytes();
	let mut start = offset.min(bytes.len());
	let mut end = offset.min(bytes.len());

	while start > 0 {
		let ch = text[..start].chars().last()?;
		if is_ident_char(ch) {
			start -= ch.len_utf8();
		} else {
			break;
		}
	}
	while end < bytes.len() {
		let ch = text[end..].chars().next()?;
		if is_ident_char(ch) {
			end += ch.len_utf8();
		} else {
			break;
		}
	}

	if start == end {
		return None;
	}
	Some((start, end, text[start..end].to_string()))
}

fn is_in_expr(text: &str, offset: usize) -> bool {
	let mut depth = 0i32;
	let mut in_string = false;
	for ch in text[..offset.min(text.len())].chars() {
		if ch == '"' {
			in_string = !in_string;
		}
		if in_string {
			continue;
		}
		if ch == '{' {
			depth += 1;
		} else if ch == '}' {
			depth -= 1;
		}
	}
	depth > 0
}

enum TagContext {
	TagName,
	AttrName { tag: String },
	ActionValue,
}

fn tag_context(text: &str, offset: usize) -> Option<TagContext> {
	let before = &text[..offset.min(text.len())];
	let last_lt = before.rfind('<')?;
	let last_gt = before.rfind('>');
	if let Some(gt) = last_gt {
		if gt > last_lt {
			return None;
		}
	}
	let tag_slice = &text[last_lt..text.len()];
	let offset_in_tag = offset.saturating_sub(last_lt);
	let is_closing = tag_slice.starts_with("</");
	let name_start = if is_closing { 2 } else { 1 };
	let name_end = tag_slice[name_start..]
		.find(|ch: char| ch.is_whitespace() || ch == '/' || ch == '>')
		.map(|idx| name_start + idx)
		.unwrap_or(tag_slice.len());
	if offset_in_tag <= name_end {
		return Some(TagContext::TagName);
	}
	let tag_name = tag_slice[name_start..name_end].trim().to_string();
	if tag_name.is_empty() {
		return Some(TagContext::TagName);
	}
	if is_action_value(tag_slice, offset_in_tag) {
		return Some(TagContext::ActionValue);
	}
	Some(TagContext::AttrName { tag: tag_name })
}

fn is_action_value(tag_slice: &str, offset_in_tag: usize) -> bool {
	for event in ["onClick", "onTextChanged", "onSliderChange", "onSelect"] {
		let needle = format!("{}=\"", event);
		let Some(start_idx) = tag_slice[..offset_in_tag.min(tag_slice.len())].rfind(&needle) else {
			continue;
		};
		let value_start = start_idx + needle.len();
		let rest = &tag_slice[value_start..];
		let Some(end_rel) = rest.find('"') else {
			continue;
		};
		let value_end = value_start + end_rel;
		if offset_in_tag >= value_start && offset_in_tag <= value_end {
			return true;
		}
	}
	false
}

fn structural_props(tag: &str) -> &'static [&'static str] {
	match tag {
		"For" => &["each", "itemAs", "indexAs", "key"],
		"If" => &["test"],
		"Scope" => &["name"],
		"Page" => &["route", "title", "state"],
		_ => &[],
	}
}

fn all_tags() -> &'static [&'static str] {
	&[
		"VStack",
		"HStack",
		"Text",
		"Button",
		"TextInput",
		"Checkbox",
		"Slider",
		"Image",
		"For",
		"If",
		"Else",
		"Scope",
		"Page",
	]
}

fn span_to_range(text: &str, start: usize, end: usize) -> Range {
	Range {
		start: offset_to_position(text, start),
		end: offset_to_position(text, end),
	}
}

fn offset_to_position(text: &str, offset: usize) -> Position {
	let mut line: u32 = 0;
	let mut col: u32 = 0;
	let mut idx: usize = 0;
	for ch in text.chars() {
		let next = idx + ch.len_utf8();
		if idx >= offset {
			break;
		}
		if ch == '\n' {
			line += 1;
			col = 0;
		} else {
			col += ch.len_utf16() as u32;
		}
		idx = next;
	}
	Position { line, character: col }
}

fn position_to_offset(text: &str, position: Position) -> usize {
	let mut line: u32 = 0;
	let mut col: u32 = 0;
	let mut idx: usize = 0;
	for ch in text.chars() {
		if line == position.line && col >= position.character {
			break;
		}
		if ch == '\n' {
			line += 1;
			col = 0;
			idx += ch.len_utf8();
			continue;
		}
		col += ch.len_utf16() as u32;
		idx += ch.len_utf8();
	}
	idx
}

#[tokio::main]
async fn main() -> Result<()> {
	let mut args = std::env::args().skip(1);
	let Some(flag) = args.next() else {
		eprintln!("usage: wui-lsp --stdio");
		std::process::exit(2);
	};
	if flag != "--stdio" {
		eprintln!("unknown flag: {}", flag);
		eprintln!("usage: wui-lsp --stdio");
		std::process::exit(2);
	}

	tracing_subscriber::fmt()
		.with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
		.with_writer(std::io::stderr)
		.init();

	let state = Arc::new(RwLock::new(AppState::default()));
	let stdin = tokio::io::stdin();
	let stdout = tokio::io::stdout();

	let (service, socket) = LspService::new(|client| Backend { client, state });
	Server::new(stdin, stdout, socket).serve(service).await;
	Ok(())
}
</file>

<file path="wui-lsp/Cargo.toml">
[package]
name = "wui-lsp"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1"
ropey = "1.6"
serde_json = "1"
tokio = { version = "1", features = ["full"] }
tower-lsp = "0.20"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
url = "2"

wgui = { path = "../wgui" }
</file>

<file path="docs/wui.md">
# WUI templates

WUI is a small JSX-like template language that compiles (or renders) to the existing `wgui` item tree.
It is designed to be deterministic and non-Turing complete: no functions, no loops outside `<For>`, and no arbitrary host calls.

## File layout

Recommended layout per app:

```
examples/your_app/
  wui/pages/
    home.wui
  src/
    main.rs
```

## Template syntax

Elements and attributes:

- Self closing: `<Button text="Add" />`
- Nested: `<VStack> ... </VStack>`
- Attribute values:
  - String: `text="Add"`
  - Expression: `value={state.title}`
  - Bare literal: `spacing=4`, `checked=true`, `x=null`
  - Boolean shorthand: `disabled` is `disabled=true`

Expressions are limited to literals, paths, unary/binary ops, ternary, and `??`.

## Structural tags

- `<For each={state.items} itemAs="item" indexAs="i" key={item.id}> ... </For>`
- `<If test={state.items.len == 0}> ... </If>` followed by `<Else> ... </Else>`
- `<Scope name="list"> ... </Scope>` prefixes action names
- `<Page route="/todo" title="Todo" state="TodoState" />`

## Events and actions

Events are declared as string names on props:

```
<Button text="Add" onClick="AddTodo" />
<TextInput value={state.new_todo_name} onTextChanged="EditNewTodo" />
<Checkbox checked={item.completed} onClick="ToggleTodo" arg={item.id} />
```

The compiler/runtime turns those into action IDs and can decode `ClientEvent` into a typed action name.

## Rendering options

There are two ways to use WUI today:

1) Compile-time codegen
- Use `wgui/src/bin/wui_gen.rs` or a build script that calls `wgui::wui::compiler::compile`.
- Emits `*_gen.rs` modules with `render()` and `decode()` helpers.

2) Runtime templates (hot reload)
- Use `wgui::wui::runtime::Template` to parse and render at runtime.
- See `examples/todo_wui` for file watching and re-render on change.

## Hot reload (runtime)

The `todo_wui` example demonstrates hot reload:

- It watches `wui/pages/todo.wui` for changes.
- On update, it re-parses the template and re-renders all connected clients.

Run it with:

```
cargo run -p todo_wui
```

## Current limits

- No user-defined functions or arbitrary host calls in templates.
- Only one event handler per element.
- `bind:*` is parsed and rendered but does not yet generate mutation actions.
- Routing metadata is collected from `<Page>` but is not wired into a router yet.

## Next steps

If you want deeper integration, consider:

- Binding protocol support (`bind:*` round trips)
- Router generation from `<Page route=...>`
- Stable key/identity plumbed into the diff engine
</file>

<file path="examples/todo_wui/src/generated/mod.rs">
pub mod todo_gen;
</file>

<file path="examples/todo_wui/src/generated/routes.gen.rs">
pub struct RouteDef {
	pub module: &'static str,
	pub route: &'static str,
}

pub const ROUTES: &[RouteDef] = &[
	RouteDef { module: "todo", route: "/todo" },
];
</file>

<file path="examples/todo_wui/src/generated/todo.gen.rs">
use wgui::*;

pub enum Action {
	EditNewTodo { value: String },
	AddTodo,
	ToggleTodo { arg: u32 },
}

pub fn decode(event: &wgui::ClientEvent) -> Option<Action> {
	match event {
		wgui::ClientEvent::OnTextChanged(ev) if ev.id == 1342686741 => Some(Action::EditNewTodo { value: ev.value.clone() }),
		wgui::ClientEvent::OnClick(ev) if ev.id == 3063551964 => Some(Action::AddTodo),
		wgui::ClientEvent::OnClick(ev) if ev.id == 1241325501 => ev.inx.map(|arg| Action::ToggleTodo { arg }),
		_ => None,
	}
}

pub fn render(state: &TodoState) -> Item {
	let mut children = Vec::new();
	children.push({
		let mut items = Vec::new();
		items.push(wgui::text("Todo List").value("Todo List"));
		items.push({
			let mut items = Vec::new();
			items.push(wgui::text_input().svalue(&state.new_todo_name).placeholder("What needs to be done?").id(1342686741));
			items.push(wgui::button("Add").text("Add").id(3063551964));
			wgui::hstack(items)
			}.spacing(4));
		items.push({
			let mut items = Vec::new();
			for (i, item) in state.items.iter().enumerate() {
				items.push({
					let mut items = Vec::new();
					items.push(wgui::checkbox().checked(item.completed).arg(item.id).id(1241325501).inx(item.id));
					items.push(wgui::text(&item.name).value(item.name));
					wgui::hstack(items)
					}.spacing(4));
			}
			wgui::vstack(items)
			}.spacing(4));
		wgui::vstack(items)
		}.spacing(8).padding(10));
	wgui::vstack(children)
}
</file>

<file path="examples/todo_wui/wui/pages/todo.wui">
<Page route="/todo" title="Todo" state="TodoState" />

<VStack spacing=8 padding=10>
  <Text value="Todo List" />
  <HStack spacing=4>
    <TextInput
      value={state.new_todo_name}
      placeholder="What needs to be done?"
      onTextChanged="EditNewTodo"
    />
    <Button text="Add" onClick="AddTodo" />
  </HStack>
  <VStack spacing=4>
    <For each={state.items} itemAs="item" indexAs="i" key={item.id}>
      <HStack spacing=4>
        <Checkbox checked={item.completed} onClick="ToggleTodo" arg={item.id} />
        <Text value={item.name} />
      </HStack>
    </For>
  </VStack>
</VStack>
</file>

<file path="examples/todo_wui/Cargo.toml">
[package]
name = "todo_wui"
version = "0.1.0"
edition = "2021"
build = "build.rs"

[dependencies]
wgui = { path = "../../wgui" }
log = "0.4"
simple_logger = "5"
tokio = { version = "1", features = ["full"] }

[build-dependencies]
wgui = { path = "../../wgui" }
</file>

<file path="wgui/src/bin/wui_gen.rs">
use std::fs;
use std::path::Path;

fn main() {
	let input_dir = std::env::args()
		.nth(1)
		.unwrap_or_else(|| "wui/pages".to_string());
	let output_dir = std::env::args()
		.nth(2)
		.unwrap_or_else(|| "src/generated".to_string());
	let input = Path::new(&input_dir);
	let output = Path::new(&output_dir);

	if !input.exists() {
		eprintln!("wui input directory not found: {}", input.display());
		std::process::exit(1);
	}
	if let Err(err) = fs::create_dir_all(output) {
		eprintln!("failed to create output dir {}: {}", output.display(), err);
		std::process::exit(1);
	}

	let mut routes = Vec::new();
	let mut modules = Vec::new();
	let entries = match fs::read_dir(input) {
		Ok(entries) => entries,
		Err(err) => {
			eprintln!("failed to read {}: {}", input.display(), err);
			std::process::exit(1);
		}
	};

	for entry in entries.flatten() {
		let path = entry.path();
		if path.extension().and_then(|ext| ext.to_str()) != Some("wui") {
			continue;
		}
		let module_name = path
			.file_stem()
			.and_then(|stem| stem.to_str())
			.unwrap_or("page")
			.to_string();
		let source = match fs::read_to_string(&path) {
			Ok(src) => src,
			Err(err) => {
				eprintln!("failed to read {}: {}", path.display(), err);
				continue;
			}
		};
		let result = wgui::wui::compiler::compile(&source, &module_name);
		let mut generated = match result {
			Ok(gen) => gen,
			Err(diags) => {
				eprintln!("failed to compile {}:", path.display());
				for diag in diags {
					eprintln!(
						" - {} at {}..{}",
						diag.message, diag.span.start, diag.span.end
					);
				}
				std::process::exit(1);
			}
		};
		for (module, route) in generated.routes.drain(..) {
			routes.push((module, route));
		}
		let out_path = output.join(format!("{}_gen.rs", module_name));
		if let Err(err) = fs::write(&out_path, generated.code) {
			eprintln!("failed to write {}: {}", out_path.display(), err);
			std::process::exit(1);
		}
		modules.push(module_name);
	}

	write_mod_rs(output, &modules);
	write_routes(output, &routes);
}

fn write_mod_rs(dir: &Path, modules: &[String]) {
	let mut contents = String::new();
	for module in modules {
		contents.push_str(&format!("pub mod {}_gen;\n", module));
	}
	let out_path = dir.join("mod.rs");
	if let Err(err) = fs::write(&out_path, contents) {
		eprintln!("failed to write {}: {}", out_path.display(), err);
		std::process::exit(1);
	}
}

fn write_routes(dir: &Path, routes: &[(String, String)]) {
	let mut contents = String::new();
	contents.push_str(
		"pub struct RouteDef {\n\tpub module: &'static str,\n\tpub route: &'static str,\n}\n\n",
	);
	contents.push_str("pub const ROUTES: &[RouteDef] = &[\n");
	for (module, route) in routes {
		contents.push_str(&format!(
			"\tRouteDef {{ module: \"{}\", route: \"{}\" }},\n",
			module, route
		));
	}
	contents.push_str("];\n");
	let out_path = dir.join("routes.gen.rs");
	if let Err(err) = fs::write(&out_path, contents) {
		eprintln!("failed to write {}: {}", out_path.display(), err);
		std::process::exit(1);
	}
}
</file>

<file path="wgui/src/wui/compiler/ir.rs">
use crate::wui::ast::Expr;

#[derive(Debug, Clone)]
pub struct IrDocument {
	pub nodes: Vec<IrNode>,
	pub actions: Vec<ActionDef>,
	pub pages: Vec<PageMeta>,
}

#[derive(Debug, Clone)]
pub struct PageMeta {
	pub module: String,
	pub route: Option<String>,
	pub title: Option<String>,
	pub state_type: Option<String>,
}

#[derive(Debug, Clone)]
pub enum IrNode {
	Widget(IrWidget),
	For(IrFor),
	If(IrIf),
	Scope(IrScope),
	Text(String),
}

#[derive(Debug, Clone)]
pub struct IrWidget {
	pub tag: String,
	pub props: Vec<IrProp>,
	pub children: Vec<IrNode>,
}

#[derive(Debug, Clone)]
pub struct IrFor {
	pub each: Expr,
	pub item: String,
	pub index: Option<String>,
	pub key: Option<Expr>,
	pub body: Vec<IrNode>,
}

#[derive(Debug, Clone)]
pub struct IrIf {
	pub test: Expr,
	pub then_body: Vec<IrNode>,
	pub else_body: Vec<IrNode>,
}

#[derive(Debug, Clone)]
pub struct IrScope {
	pub name: String,
	pub body: Vec<IrNode>,
}

#[derive(Debug, Clone)]
pub enum IrProp {
	Value {
		name: String,
		expr: Expr,
	},
	Literal {
		name: String,
		value: String,
	},
	Bool {
		name: String,
		value: bool,
	},
	Number {
		name: String,
		value: f64,
	},
	Event {
		name: String,
		action: String,
		arg: Option<Expr>,
	},
	Bind {
		name: String,
		expr: Expr,
	},
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EventKind {
	Click,
	TextChanged,
	SliderChange,
	Select,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ActionPayload {
	None,
	U32,
	String,
	I32,
}

#[derive(Debug, Clone)]
pub struct ActionDef {
	pub name: String,
	pub kind: EventKind,
	pub payload: ActionPayload,
	pub id: u32,
}
</file>

<file path="wgui/src/wui/compiler/lower.rs">
use crate::wui::ast::{AttrValue, Element, Expr, Node};
use crate::wui::compiler::ir::{
	ActionDef, ActionPayload, EventKind, IrDocument, IrFor, IrIf, IrNode, IrProp, IrScope,
	IrWidget, PageMeta,
};
use crate::wui::compiler::registry::schema_for;
use crate::wui::diagnostic::{Diagnostic, Span};
use std::collections::HashMap;

pub fn lower(
	doc: &crate::wui::compiler::validate::ValidatedDocument,
	module_name: &str,
	diags: &mut Vec<Diagnostic>,
) -> IrDocument {
	let mut ctx = LowerContext::new(module_name);
	let nodes = lower_nodes(&doc.nodes, &mut ctx, diags);
	IrDocument {
		nodes,
		actions: ctx.actions,
		pages: ctx.pages,
	}
}

struct LowerContext {
	module: String,
	scope_stack: Vec<String>,
	actions: Vec<ActionDef>,
	action_ids: HashMap<u32, String>,
	pages: Vec<PageMeta>,
}

impl LowerContext {
	fn new(module_name: &str) -> Self {
		Self {
			module: module_name.to_string(),
			scope_stack: Vec::new(),
			actions: Vec::new(),
			action_ids: HashMap::new(),
			pages: Vec::new(),
		}
	}

	fn scoped_action(&self, name: &str) -> String {
		if self.scope_stack.is_empty() {
			name.to_string()
		} else {
			format!("{}/{}", self.scope_stack.join("/"), name)
		}
	}

	fn add_action(
		&mut self,
		name: String,
		kind: EventKind,
		payload: ActionPayload,
		span: Span,
		diags: &mut Vec<Diagnostic>,
	) {
		let id = hash_action_id(&name);
		if let Some(existing) = self.action_ids.get(&id) {
			if existing != &name {
				diags.push(Diagnostic::new(
					format!("action id collision between {} and {}", existing, name),
					span,
				));
			}
		} else {
			self.action_ids.insert(id, name.clone());
		}
		if let Some(existing) = self.actions.iter().find(|a| a.name == name) {
			if existing.kind != kind || existing.payload != payload {
				diags.push(Diagnostic::new(
					format!("action {} used with conflicting payloads", name),
					span,
				));
			}
			return;
		}
		self.actions.push(ActionDef {
			name,
			kind,
			payload,
			id,
		});
	}
}

fn lower_nodes(nodes: &[Node], ctx: &mut LowerContext, diags: &mut Vec<Diagnostic>) -> Vec<IrNode> {
	let mut out = Vec::new();
	let mut i = 0;
	while i < nodes.len() {
		match &nodes[i] {
			Node::Element(el) if el.name == "If" => {
				let then_body = lower_nodes(&el.children, ctx, diags);
				let mut else_body = Vec::new();
				if i + 1 < nodes.len() {
					if let Node::Element(next) = &nodes[i + 1] {
						if next.name == "Else" {
							else_body = lower_nodes(&next.children, ctx, diags);
							i += 1;
						}
					}
				}
				if let Some(test) = get_expr_attr(el, "test") {
					out.push(IrNode::If(IrIf {
						test,
						then_body,
						else_body,
					}));
				}
			}
			Node::Element(el) if el.name == "For" => {
				let each = get_expr_attr(el, "each")
					.unwrap_or_else(|| Expr::Literal(crate::wui::ast::Literal::Null, el.span));
				let item = get_string_attr(el, "itemAs").unwrap_or_else(|| "item".to_string());
				let index = get_string_attr(el, "indexAs");
				let key = get_expr_attr(el, "key");
				let body = lower_nodes(&el.children, ctx, diags);
				out.push(IrNode::For(IrFor {
					each,
					item,
					index,
					key,
					body,
				}));
			}
			Node::Element(el) if el.name == "Scope" => {
				let name = get_string_attr(el, "name").unwrap_or_else(|| "scope".to_string());
				ctx.scope_stack.push(name.clone());
				let body = lower_nodes(&el.children, ctx, diags);
				ctx.scope_stack.pop();
				out.push(IrNode::Scope(IrScope { name, body }));
			}
			Node::Element(el) if el.name == "Page" => {
				let route = get_string_attr(el, "route");
				let title = get_string_attr(el, "title");
				let state_type = get_string_attr(el, "state");
				ctx.pages.push(PageMeta {
					module: ctx.module.clone(),
					route,
					title,
					state_type,
				});
			}
			Node::Element(el) => {
				if let Some(widget) = lower_widget(el, ctx, diags) {
					out.push(IrNode::Widget(widget));
				}
			}
			Node::Text(text, _) => out.push(IrNode::Text(text.clone())),
			Node::Expr(_) => {
				diags.push(Diagnostic::new(
					"bare expressions are not supported as nodes",
					el_span(nodes[i].clone()),
				));
			}
		}
		i += 1;
	}
	out
}

fn el_span(node: Node) -> Span {
	match node {
		Node::Element(el) => el.span,
		Node::Text(_, span) => span,
		Node::Expr(expr) => expr.span(),
	}
}

fn lower_widget(
	el: &Element,
	ctx: &mut LowerContext,
	diags: &mut Vec<Diagnostic>,
) -> Option<IrWidget> {
	let Some(schema) = schema_for(&el.name) else {
		return None;
	};
	let mut props = Vec::new();
	let mut event_prop: Option<(String, EventKind, Option<Expr>, Span)> = None;

	for attr in &el.attrs {
		if let Some(def) = schema.props.iter().find(|p| p.name == attr.name) {
			match def.kind {
				crate::wui::compiler::registry::PropKind::Event(kind) => {
					let action_name = match &attr.value {
						AttrValue::String(name, _) => name.clone(),
						_ => continue,
					};
					let scoped = ctx.scoped_action(&action_name);
					let arg = get_expr_like(el, "arg");
					event_prop = Some((scoped, kind, arg, attr.span));
				}
				crate::wui::compiler::registry::PropKind::Bind(_) => {
					if let AttrValue::Expr(expr) = &attr.value {
						let prop_name = normalize_prop_name(&el.name, &attr.name);
						props.push(IrProp::Bind {
							name: prop_name,
							expr: expr.clone(),
						});
					}
				}
				crate::wui::compiler::registry::PropKind::Value(_) => {
					if attr.name == "arg" {
						continue;
					}
					let prop_name = normalize_prop_name(&el.name, &attr.name);
					match &attr.value {
						AttrValue::String(value, _) => props.push(IrProp::Literal {
							name: prop_name,
							value: value.clone(),
						}),
						AttrValue::Number(value, _) => props.push(IrProp::Number {
							name: prop_name,
							value: *value,
						}),
						AttrValue::Bool(value, _) => props.push(IrProp::Bool {
							name: prop_name,
							value: *value,
						}),
						AttrValue::Expr(expr) => props.push(IrProp::Value {
							name: prop_name,
							expr: expr.clone(),
						}),
						AttrValue::Null(_) => {}
					}
				}
			}
		}
	}

	if let Some((action, kind, arg, span)) = event_prop {
		let payload = match kind {
			EventKind::Click => {
				if arg.is_some() {
					ActionPayload::U32
				} else {
					ActionPayload::None
				}
			}
			EventKind::TextChanged => ActionPayload::String,
			EventKind::SliderChange => ActionPayload::I32,
			EventKind::Select => ActionPayload::String,
		};
		ctx.add_action(action.clone(), kind, payload, span, diags);
		props.push(IrProp::Event {
			name: kind_name(kind),
			action,
			arg,
		});
	}

	let children = lower_nodes(&el.children, ctx, diags);
	Some(IrWidget {
		tag: el.name.clone(),
		props,
		children,
	})
}

fn kind_name(kind: EventKind) -> String {
	match kind {
		EventKind::Click => "onClick".to_string(),
		EventKind::TextChanged => "onTextChanged".to_string(),
		EventKind::SliderChange => "onSliderChange".to_string(),
		EventKind::Select => "onSelect".to_string(),
	}
}

fn get_string_attr(el: &Element, name: &str) -> Option<String> {
	for attr in &el.attrs {
		if attr.name == name {
			if let AttrValue::String(value, _) = &attr.value {
				return Some(value.clone());
			}
		}
	}
	None
}

fn get_expr_attr(el: &Element, name: &str) -> Option<Expr> {
	for attr in &el.attrs {
		if attr.name == name {
			if let AttrValue::Expr(expr) = &attr.value {
				return Some(expr.clone());
			}
		}
	}
	None
}

fn get_expr_like(el: &Element, name: &str) -> Option<Expr> {
	for attr in &el.attrs {
		if attr.name == name {
			match &attr.value {
				AttrValue::Expr(expr) => return Some(expr.clone()),
				AttrValue::Number(value, span) => {
					return Some(Expr::Literal(
						crate::wui::ast::Literal::Number(*value),
						*span,
					));
				}
				_ => {}
			}
		}
	}
	None
}

fn normalize_prop_name(tag: &str, name: &str) -> String {
	match (tag, name) {
		("TextInput", "value") => "svalue".to_string(),
		("TextInput", "bind:value") => "bind:svalue".to_string(),
		("Slider", "value") => "ivalue".to_string(),
		("Slider", "bind:value") => "bind:ivalue".to_string(),
		_ => name.to_string(),
	}
}

fn hash_action_id(input: &str) -> u32 {
	const FNV_OFFSET: u32 = 0x811c9dc5;
	const FNV_PRIME: u32 = 0x01000193;
	let mut hash = FNV_OFFSET;
	for byte in input.as_bytes() {
		hash ^= *byte as u32;
		hash = hash.wrapping_mul(FNV_PRIME);
	}
	if hash == 0 {
		1
	} else {
		hash
	}
}
</file>

<file path="wgui/src/wui/compiler/mod.rs">
pub mod codegen;
pub mod ir;
pub mod lower;
pub mod registry;
pub mod validate;

use crate::wui::diagnostic::Diagnostic;

#[derive(Debug)]
pub struct GeneratedModule {
	pub code: String,
	pub routes: Vec<(String, String)>,
}

pub fn compile(source: &str, module_name: &str) -> Result<GeneratedModule, Vec<Diagnostic>> {
	let parsed = crate::wui::parser::Parser::new(source).parse();
	let mut diags = parsed.diagnostics;
	let validated = validate::validate(&parsed.nodes, &mut diags);
	let Some(validated) = validated else {
		return Err(diags);
	};
	let lowered = lower::lower(&validated, module_name, &mut diags);
	if !diags.is_empty() {
		return Err(diags);
	}
	let code = codegen::generate(&lowered);
	let routes = lowered
		.pages
		.iter()
		.filter_map(|page| page.route.clone().map(|route| (page.module.clone(), route)))
		.collect();
	Ok(GeneratedModule { code, routes })
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn compiles_actions_and_routes() {
		let src = r#"
<Page route="/todo" state="TodoState" />
<VStack>
	<Button text="Add" onClick="AddTodo" />
	<TextInput value={state.new_todo_name} onTextChanged="EditNewTodo" />
</VStack>
"#;
		let generated = compile(src, "todo").expect("compile should succeed");
		assert!(generated.code.contains("pub enum Action"));
		assert!(generated.code.contains("AddTodo"));
		assert!(generated.code.contains("EditNewTodo"));
		assert!(generated.code.contains("pub fn render(state: &TodoState)"));
		assert_eq!(
			generated.routes,
			vec![("todo".to_string(), "/todo".to_string())]
		);
	}

	#[test]
	fn reports_unknown_tag() {
		let src = "<UnknownTag />";
		let result = compile(src, "bad");
		assert!(result.is_err());
	}
}
</file>

<file path="wgui/src/wui/compiler/registry.rs">
use crate::wui::compiler::ir::EventKind;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ValueType {
	String,
	Number,
	Bool,
}

#[derive(Debug, Clone)]
pub enum PropKind {
	Value(ValueType),
	Event(EventKind),
	Bind(ValueType),
}

#[derive(Debug, Clone)]
pub struct PropSchema {
	pub name: &'static str,
	pub kind: PropKind,
}

#[derive(Debug, Clone)]
pub struct TagSchema {
	pub name: &'static str,
	pub props: &'static [PropSchema],
}

pub fn schema_for(tag: &str) -> Option<TagSchema> {
	match tag {
		"VStack" => Some(TagSchema {
			name: "VStack",
			props: layout_props(),
		}),
		"HStack" => Some(TagSchema {
			name: "HStack",
			props: layout_props(),
		}),
		"Text" => Some(TagSchema {
			name: "Text",
			props: &[
				PropSchema {
					name: "value",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "textAlign",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "color",
					kind: PropKind::Value(ValueType::String),
				},
			],
		}),
		"Button" => Some(TagSchema {
			name: "Button",
			props: &[
				PropSchema {
					name: "text",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "onClick",
					kind: PropKind::Event(EventKind::Click),
				},
				PropSchema {
					name: "arg",
					kind: PropKind::Value(ValueType::Number),
				},
			],
		}),
		"TextInput" => Some(TagSchema {
			name: "TextInput",
			props: &[
				PropSchema {
					name: "value",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "bind:value",
					kind: PropKind::Bind(ValueType::String),
				},
				PropSchema {
					name: "placeholder",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "onTextChanged",
					kind: PropKind::Event(EventKind::TextChanged),
				},
			],
		}),
		"Checkbox" => Some(TagSchema {
			name: "Checkbox",
			props: &[
				PropSchema {
					name: "checked",
					kind: PropKind::Value(ValueType::Bool),
				},
				PropSchema {
					name: "bind:checked",
					kind: PropKind::Bind(ValueType::Bool),
				},
				PropSchema {
					name: "onClick",
					kind: PropKind::Event(EventKind::Click),
				},
				PropSchema {
					name: "arg",
					kind: PropKind::Value(ValueType::Number),
				},
			],
		}),
		"Slider" => Some(TagSchema {
			name: "Slider",
			props: &[
				PropSchema {
					name: "min",
					kind: PropKind::Value(ValueType::Number),
				},
				PropSchema {
					name: "max",
					kind: PropKind::Value(ValueType::Number),
				},
				PropSchema {
					name: "value",
					kind: PropKind::Value(ValueType::Number),
				},
				PropSchema {
					name: "step",
					kind: PropKind::Value(ValueType::Number),
				},
				PropSchema {
					name: "onSliderChange",
					kind: PropKind::Event(EventKind::SliderChange),
				},
			],
		}),
		"Image" => Some(TagSchema {
			name: "Image",
			props: &[
				PropSchema {
					name: "src",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "alt",
					kind: PropKind::Value(ValueType::String),
				},
				PropSchema {
					name: "objectFit",
					kind: PropKind::Value(ValueType::String),
				},
			],
		}),
		_ => None,
	}
}

pub fn is_structural(tag: &str) -> bool {
	matches!(tag, "For" | "If" | "Else" | "Scope" | "Page")
}

fn layout_props() -> &'static [PropSchema] {
	&[
		PropSchema {
			name: "spacing",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "padding",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "paddingLeft",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "paddingRight",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "paddingTop",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "paddingBottom",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "margin",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "marginLeft",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "marginRight",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "marginTop",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "marginBottom",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "backgroundColor",
			kind: PropKind::Value(ValueType::String),
		},
		PropSchema {
			name: "border",
			kind: PropKind::Value(ValueType::String),
		},
		PropSchema {
			name: "width",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "height",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "minWidth",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "maxWidth",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "minHeight",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "maxHeight",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "grow",
			kind: PropKind::Value(ValueType::Number),
		},
		PropSchema {
			name: "textAlign",
			kind: PropKind::Value(ValueType::String),
		},
		PropSchema {
			name: "cursor",
			kind: PropKind::Value(ValueType::String),
		},
		PropSchema {
			name: "wrap",
			kind: PropKind::Value(ValueType::Bool),
		},
		PropSchema {
			name: "overflow",
			kind: PropKind::Value(ValueType::String),
		},
	]
}
</file>

<file path="wgui/src/wui/compiler/validate.rs">
use crate::wui::ast::{AttrValue, Expr, Literal, Node};
use crate::wui::compiler::registry::{is_structural, schema_for, PropKind, ValueType};
use crate::wui::diagnostic::Diagnostic;

#[derive(Debug, Clone)]
pub struct ValidatedDocument {
	pub nodes: Vec<Node>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ExprType {
	String,
	Number,
	Bool,
	Null,
	Unknown,
}

pub fn validate(nodes: &[Node], diags: &mut Vec<Diagnostic>) -> Option<ValidatedDocument> {
	for node in nodes {
		validate_node(node, diags);
	}
	if diags.is_empty() {
		Some(ValidatedDocument {
			nodes: nodes.to_vec(),
		})
	} else {
		None
	}
}

fn validate_node(node: &Node, diags: &mut Vec<Diagnostic>) {
	match node {
		Node::Element(el) => {
			if is_structural(&el.name) {
				validate_structural(el, diags);
			} else {
				validate_widget(el, diags);
			}
			for child in &el.children {
				validate_node(child, diags);
			}
		}
		Node::Text(_, _) | Node::Expr(_) => {}
	}
}

fn validate_structural(el: &crate::wui::ast::Element, diags: &mut Vec<Diagnostic>) {
	match el.name.as_str() {
		"For" => {
			require_attr(el, "each", diags);
			allow_only(el, &["each", "itemAs", "indexAs", "key"], diags);
		}
		"If" => {
			require_attr(el, "test", diags);
			allow_only(el, &["test"], diags);
		}
		"Else" => {
			if !el.attrs.is_empty() {
				diags.push(Diagnostic::new("Else does not take attributes", el.span));
			}
		}
		"Scope" => {
			require_attr(el, "name", diags);
			allow_only(el, &["name"], diags);
		}
		"Page" => {
			allow_only(el, &["route", "title", "state"], diags);
		}
		_ => {}
	}
}

fn validate_widget(el: &crate::wui::ast::Element, diags: &mut Vec<Diagnostic>) {
	let Some(schema) = schema_for(&el.name) else {
		diags.push(Diagnostic::new("unknown tag", el.span));
		return;
	};
	let mut event_count = 0;
	for attr in &el.attrs {
		let Some(prop) = schema.props.iter().find(|p| p.name == attr.name) else {
			diags.push(Diagnostic::new(
				format!("unknown prop {}", attr.name),
				attr.span,
			));
			continue;
		};
		match prop.kind {
			PropKind::Event(_) => {
				event_count += 1;
				if !matches!(attr.value, AttrValue::String(_, _)) {
					diags.push(Diagnostic::new(
						"event handlers must be string literals",
						attr.span,
					));
				}
			}
			PropKind::Bind(value_type) | PropKind::Value(value_type) => {
				if !attr_value_matches(&attr.value, value_type) {
					diags.push(Diagnostic::new(
						format!("invalid value for {}", attr.name),
						attr.span,
					));
				}
			}
		}
	}
	if event_count > 1 {
		diags.push(Diagnostic::new(
			"only one event handler per element is supported",
			el.span,
		));
	}
	check_bind_conflicts(el, diags);
}

fn check_bind_conflicts(el: &crate::wui::ast::Element, diags: &mut Vec<Diagnostic>) {
	let mut has_value = false;
	let mut has_bind = false;
	for attr in &el.attrs {
		if attr.name == "value" {
			has_value = true;
		}
		if attr.name.starts_with("bind:") {
			has_bind = true;
		}
	}
	if has_value && has_bind {
		diags.push(Diagnostic::new(
			"cannot use value with bind:* on same element",
			el.span,
		));
	}
}

fn require_attr(el: &crate::wui::ast::Element, name: &str, diags: &mut Vec<Diagnostic>) {
	if !el.attrs.iter().any(|attr| attr.name == name) {
		diags.push(Diagnostic::new(
			format!("missing required attribute {}", name),
			el.span,
		));
	}
}

fn allow_only(el: &crate::wui::ast::Element, allowed: &[&str], diags: &mut Vec<Diagnostic>) {
	for attr in &el.attrs {
		if !allowed.contains(&attr.name.as_str()) {
			diags.push(Diagnostic::new(
				format!("unknown attribute {}", attr.name),
				attr.span,
			));
		}
	}
}

fn attr_value_matches(value: &AttrValue, expected: ValueType) -> bool {
	match expected {
		ValueType::String => matches!(attr_value_type(value), ExprType::String | ExprType::Unknown),
		ValueType::Number => matches!(attr_value_type(value), ExprType::Number | ExprType::Unknown),
		ValueType::Bool => matches!(attr_value_type(value), ExprType::Bool | ExprType::Unknown),
	}
}

fn attr_value_type(value: &AttrValue) -> ExprType {
	match value {
		AttrValue::String(_, _) => ExprType::String,
		AttrValue::Number(_, _) => ExprType::Number,
		AttrValue::Bool(_, _) => ExprType::Bool,
		AttrValue::Null(_) => ExprType::Null,
		AttrValue::Expr(expr) => expr_type(expr),
	}
}

fn expr_type(expr: &Expr) -> ExprType {
	match expr {
		Expr::Literal(lit, _) => match lit {
			Literal::String(_) => ExprType::String,
			Literal::Number(_) => ExprType::Number,
			Literal::Bool(_) => ExprType::Bool,
			Literal::Null => ExprType::Null,
		},
		_ => ExprType::Unknown,
	}
}
</file>

<file path="wgui/src/wui/ast.rs">
use crate::wui::diagnostic::Span;

#[derive(Debug, Clone)]
pub enum Node {
	Element(Element),
	Text(String, Span),
	Expr(Expr),
}

#[derive(Debug, Clone)]
pub struct Element {
	pub name: String,
	pub attrs: Vec<Attribute>,
	pub children: Vec<Node>,
	pub span: Span,
}

#[derive(Debug, Clone)]
pub struct Attribute {
	pub name: String,
	pub value: AttrValue,
	pub span: Span,
}

#[derive(Debug, Clone)]
pub enum AttrValue {
	String(String, Span),
	Number(f64, Span),
	Bool(bool, Span),
	Null(Span),
	Expr(Expr),
}

#[derive(Debug, Clone)]
pub enum Expr {
	Literal(Literal, Span),
	Path(Vec<String>, Span),
	Unary {
		op: UnaryOp,
		expr: Box<Expr>,
		span: Span,
	},
	Binary {
		left: Box<Expr>,
		op: BinaryOp,
		right: Box<Expr>,
		span: Span,
	},
	Ternary {
		cond: Box<Expr>,
		then_expr: Box<Expr>,
		else_expr: Box<Expr>,
		span: Span,
	},
	Coalesce {
		left: Box<Expr>,
		right: Box<Expr>,
		span: Span,
	},
}

#[derive(Debug, Clone)]
pub enum Literal {
	String(String),
	Number(f64),
	Bool(bool),
	Null,
}

#[derive(Debug, Clone, Copy)]
pub enum UnaryOp {
	Not,
	Neg,
}

#[derive(Debug, Clone, Copy)]
pub enum BinaryOp {
	Add,
	Sub,
	Mul,
	Div,
	Mod,
	Eq,
	Neq,
	Lt,
	Lte,
	Gt,
	Gte,
	And,
	Or,
}

impl Expr {
	pub fn span(&self) -> Span {
		match self {
			Expr::Literal(_, span)
			| Expr::Path(_, span)
			| Expr::Unary { span, .. }
			| Expr::Binary { span, .. }
			| Expr::Ternary { span, .. }
			| Expr::Coalesce { span, .. } => *span,
		}
	}
}
</file>

<file path="wgui/src/wui/diagnostic.rs">
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Span {
	pub start: usize,
	pub end: usize,
}

impl Span {
	pub fn new(start: usize, end: usize) -> Self {
		Self { start, end }
	}
}

#[derive(Debug, Clone)]
pub struct Diagnostic {
	pub message: String,
	pub span: Span,
}

impl Diagnostic {
	pub fn new(message: impl Into<String>, span: Span) -> Self {
		Self {
			message: message.into(),
			span,
		}
	}
}
</file>

<file path="wgui/src/wui/expr.rs">
use crate::wui::ast::{BinaryOp, Expr, Literal, UnaryOp};
use crate::wui::diagnostic::{Diagnostic, Span};

#[derive(Debug, Clone)]
pub struct ExprParser<'a> {
	src: &'a str,
	offset: usize,
	pos: usize,
}

impl<'a> ExprParser<'a> {
	pub fn new(src: &'a str, offset: usize) -> Self {
		Self {
			src,
			offset,
			pos: 0,
		}
	}

	pub fn parse(mut self) -> Result<Expr, Diagnostic> {
		let expr = self.parse_ternary()?;
		self.skip_ws();
		if self.pos < self.src.len() {
			let span = self.span_here();
			return Err(Diagnostic::new("unexpected token", span));
		}
		Ok(expr)
	}

	fn parse_ternary(&mut self) -> Result<Expr, Diagnostic> {
		let start = self.current_offset();
		let mut expr = self.parse_coalesce()?;
		self.skip_ws();
		if self.consume_char('?') {
			let then_expr = self.parse_ternary()?;
			self.expect_char(':')?;
			let else_expr = self.parse_ternary()?;
			let span = Span::new(start, else_expr.span().end);
			expr = Expr::Ternary {
				cond: Box::new(expr),
				then_expr: Box::new(then_expr),
				else_expr: Box::new(else_expr),
				span,
			};
		}
		Ok(expr)
	}

	fn parse_coalesce(&mut self) -> Result<Expr, Diagnostic> {
		let start = self.current_offset();
		let mut expr = self.parse_or()?;
		self.skip_ws();
		while self.peek_str("??") {
			self.pos += 2;
			let right = self.parse_or()?;
			let span = Span::new(start, right.span().end);
			expr = Expr::Coalesce {
				left: Box::new(expr),
				right: Box::new(right),
				span,
			};
			self.skip_ws();
		}
		Ok(expr)
	}

	fn parse_or(&mut self) -> Result<Expr, Diagnostic> {
		self.parse_binary(Self::parse_and, &[("||", BinaryOp::Or)])
	}

	fn parse_and(&mut self) -> Result<Expr, Diagnostic> {
		self.parse_binary(Self::parse_equality, &[("&&", BinaryOp::And)])
	}

	fn parse_equality(&mut self) -> Result<Expr, Diagnostic> {
		self.parse_binary(
			Self::parse_compare,
			&[("==", BinaryOp::Eq), ("!=", BinaryOp::Neq)],
		)
	}

	fn parse_compare(&mut self) -> Result<Expr, Diagnostic> {
		self.parse_binary(
			Self::parse_add,
			&[
				("<=", BinaryOp::Lte),
				(">=", BinaryOp::Gte),
				("<", BinaryOp::Lt),
				(">", BinaryOp::Gt),
			],
		)
	}

	fn parse_add(&mut self) -> Result<Expr, Diagnostic> {
		self.parse_binary(
			Self::parse_mul,
			&[("+", BinaryOp::Add), ("-", BinaryOp::Sub)],
		)
	}

	fn parse_mul(&mut self) -> Result<Expr, Diagnostic> {
		self.parse_binary(
			Self::parse_unary,
			&[
				("*", BinaryOp::Mul),
				("/", BinaryOp::Div),
				("%", BinaryOp::Mod),
			],
		)
	}

	fn parse_binary<F>(
		&mut self,
		next: F,
		ops: &[(&'static str, BinaryOp)],
	) -> Result<Expr, Diagnostic>
	where
		F: Fn(&mut Self) -> Result<Expr, Diagnostic>,
	{
		let mut expr = next(self)?;
		loop {
			self.skip_ws();
			let mut matched = None;
			for (token, op) in ops {
				if self.peek_str(token) {
					matched = Some((*token, *op));
					break;
				}
			}
			let Some((token, op)) = matched else {
				break;
			};
			self.pos += token.len();
			let right = next(self)?;
			let span = Span::new(expr.span().start, right.span().end);
			expr = Expr::Binary {
				left: Box::new(expr),
				op,
				right: Box::new(right),
				span,
			};
		}
		Ok(expr)
	}

	fn parse_unary(&mut self) -> Result<Expr, Diagnostic> {
		self.skip_ws();
		let start = self.current_offset();
		if self.consume_char('!') {
			let expr = self.parse_unary()?;
			let span = Span::new(start, expr.span().end);
			return Ok(Expr::Unary {
				op: UnaryOp::Not,
				expr: Box::new(expr),
				span,
			});
		}
		if self.consume_char('-') {
			let expr = self.parse_unary()?;
			let span = Span::new(start, expr.span().end);
			return Ok(Expr::Unary {
				op: UnaryOp::Neg,
				expr: Box::new(expr),
				span,
			});
		}
		self.parse_primary()
	}

	fn parse_primary(&mut self) -> Result<Expr, Diagnostic> {
		self.skip_ws();
		let start = self.current_offset();
		if self.consume_char('(') {
			let expr = self.parse_ternary()?;
			self.expect_char(')')?;
			return Ok(expr);
		}
		if let Some(value) = self.parse_string()? {
			let span = Span::new(start, self.current_offset());
			return Ok(Expr::Literal(Literal::String(value), span));
		}
		if let Some(lit) = self.parse_literal()? {
			let span = Span::new(start, self.current_offset());
			return Ok(Expr::Literal(lit, span));
		}
		if let Some(path) = self.parse_path()? {
			let span = Span::new(start, self.current_offset());
			return Ok(Expr::Path(path, span));
		}
		Err(Diagnostic::new("expected expression", self.span_here()))
	}

	fn parse_string(&mut self) -> Result<Option<String>, Diagnostic> {
		self.skip_ws();
		if !self.consume_char('"') {
			return Ok(None);
		}
		let mut out = String::new();
		while let Some(ch) = self.peek_char() {
			self.pos += ch.len_utf8();
			match ch {
				'"' => return Ok(Some(out)),
				'\\' => {
					let next = self
						.peek_char()
						.ok_or_else(|| Diagnostic::new("unterminated escape", self.span_here()))?;
					self.pos += next.len_utf8();
					match next {
						'"' => out.push('"'),
						'\\' => out.push('\\'),
						'n' => out.push('\n'),
						_ => return Err(Diagnostic::new("invalid escape", self.span_here())),
					}
				}
				_ => out.push(ch),
			}
		}
		Err(Diagnostic::new("unterminated string", self.span_here()))
	}

	fn parse_literal(&mut self) -> Result<Option<Literal>, Diagnostic> {
		self.skip_ws();
		if self.peek_str("true") && self.is_delim(4) {
			self.pos += 4;
			return Ok(Some(Literal::Bool(true)));
		}
		if self.peek_str("false") && self.is_delim(5) {
			self.pos += 5;
			return Ok(Some(Literal::Bool(false)));
		}
		if self.peek_str("null") && self.is_delim(4) {
			self.pos += 4;
			return Ok(Some(Literal::Null));
		}
		let start = self.pos;
		let mut saw_digit = false;
		let mut saw_dot = false;
		while let Some(ch) = self.peek_char() {
			if ch.is_ascii_digit() {
				saw_digit = true;
				self.pos += 1;
				continue;
			}
			if ch == '.' && !saw_dot {
				saw_dot = true;
				self.pos += 1;
				continue;
			}
			break;
		}
		if saw_digit {
			let slice = &self.src[start..self.pos];
			let value = slice
				.parse::<f64>()
				.map_err(|_| Diagnostic::new("invalid number", self.span_here()))?;
			return Ok(Some(Literal::Number(value)));
		}
		Ok(None)
	}

	fn parse_path(&mut self) -> Result<Option<Vec<String>>, Diagnostic> {
		self.skip_ws();
		let Some(ident) = self.parse_ident() else {
			return Ok(None);
		};
		let mut parts = vec![ident];
		loop {
			self.skip_ws();
			if !self.consume_char('.') {
				break;
			}
			let ident = self
				.parse_ident()
				.ok_or_else(|| Diagnostic::new("expected identifier", self.span_here()))?;
			parts.push(ident);
		}
		Ok(Some(parts))
	}

	fn parse_ident(&mut self) -> Option<String> {
		self.skip_ws();
		let mut iter = self.src[self.pos..].char_indices();
		let Some((_, first)) = iter.next() else {
			return None;
		};
		if !(first.is_ascii_alphabetic() || first == '_') {
			return None;
		}
		let mut end = self.pos + first.len_utf8();
		for (offset, ch) in iter {
			if ch.is_ascii_alphanumeric() || ch == '_' {
				end = self.pos + offset + ch.len_utf8();
			} else {
				break;
			}
		}
		let ident = self.src[self.pos..end].to_string();
		self.pos = end;
		Some(ident)
	}

	fn skip_ws(&mut self) {
		while let Some(ch) = self.peek_char() {
			if ch.is_whitespace() {
				self.pos += ch.len_utf8();
			} else {
				break;
			}
		}
	}

	fn consume_char(&mut self, ch: char) -> bool {
		self.skip_ws();
		if self.peek_char() == Some(ch) {
			self.pos += ch.len_utf8();
			true
		} else {
			false
		}
	}

	fn expect_char(&mut self, ch: char) -> Result<(), Diagnostic> {
		if self.consume_char(ch) {
			Ok(())
		} else {
			Err(Diagnostic::new("expected character", self.span_here()))
		}
	}

	fn peek_char(&self) -> Option<char> {
		self.src[self.pos..].chars().next()
	}

	fn peek_str(&self, s: &str) -> bool {
		self.src[self.pos..].starts_with(s)
	}

	fn is_delim(&self, len: usize) -> bool {
		let idx = self.pos + len;
		if idx >= self.src.len() {
			return true;
		}
		match self.src[idx..].chars().next() {
			Some(ch) => !(ch.is_ascii_alphanumeric() || ch == '_' || ch == '.'),
			None => true,
		}
	}

	fn span_here(&self) -> Span {
		let pos = self.current_offset();
		Span::new(pos, pos)
	}

	fn current_offset(&self) -> usize {
		self.offset + self.pos
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn parse_simple_expression() {
		let expr = ExprParser::new("state.count + 1", 0).parse().unwrap();
		match expr {
			Expr::Binary { op, .. } => assert!(matches!(op, BinaryOp::Add)),
			_ => panic!("expected binary"),
		}
	}
}
</file>

<file path="wgui/src/wui/mod.rs">
pub mod ast;
pub mod compiler;
pub mod diagnostic;
pub mod expr;
pub mod parser;
pub mod runtime;
</file>

<file path="wgui/src/wui/parser.rs">
use crate::wui::ast::{AttrValue, Attribute, Element, Expr, Node};
use crate::wui::diagnostic::{Diagnostic, Span};
use crate::wui::expr::ExprParser;

#[derive(Debug)]
pub struct ParsedFile {
	pub nodes: Vec<Node>,
	pub diagnostics: Vec<Diagnostic>,
}

pub struct Parser<'a> {
	src: &'a str,
	pos: usize,
	diagnostics: Vec<Diagnostic>,
}

impl<'a> Parser<'a> {
	pub fn new(src: &'a str) -> Self {
		Self {
			src,
			pos: 0,
			diagnostics: Vec::new(),
		}
	}

	pub fn parse(mut self) -> ParsedFile {
		let nodes = self.parse_nodes(None);
		ParsedFile {
			nodes,
			diagnostics: self.diagnostics,
		}
	}

	fn parse_nodes(&mut self, stop_tag: Option<&str>) -> Vec<Node> {
		let mut nodes = Vec::new();
		loop {
			self.skip_ws();
			if self.eof() {
				break;
			}
			if let Some(tag) = stop_tag {
				if self.peek_str("</") && self.peek_str_at(tag, 2) {
					break;
				}
			}
			if self.peek_char() == Some('<') {
				match self.parse_element() {
					Some(node) => nodes.push(Node::Element(node)),
					None => break,
				}
				continue;
			}
			if self.peek_char() == Some('{') {
				if let Some(expr) = self.parse_expr_node() {
					nodes.push(Node::Expr(expr));
				}
				continue;
			}
			if let Some(text) = self.parse_text() {
				nodes.push(text);
			} else {
				break;
			}
		}
		nodes
	}

	fn parse_element(&mut self) -> Option<Element> {
		let start = self.pos;
		self.expect_char('<')?;
		if self.consume_char('/') {
			self.diagnostics
				.push(Diagnostic::new("unexpected closing tag", self.span_here()));
			return None;
		}
		let name = self.parse_ident()?;
		let attrs = self.parse_attributes();
		self.skip_ws();
		if self.consume_char('/') {
			self.expect_char('>')?;
			let span = Span::new(start, self.pos);
			return Some(Element {
				name,
				attrs,
				children: Vec::new(),
				span,
			});
		}
		self.expect_char('>')?;
		let children = self.parse_nodes(Some(&name));
		self.expect_char('<')?;
		self.expect_char('/')?;
		let closing = self.parse_ident().unwrap_or_default();
		if closing != name {
			let span = Span::new(start, self.pos);
			self.diagnostics
				.push(Diagnostic::new("mismatched closing tag", span));
		}
		self.skip_ws();
		self.expect_char('>')?;
		let span = Span::new(start, self.pos);
		Some(Element {
			name,
			attrs,
			children,
			span,
		})
	}

	fn parse_attributes(&mut self) -> Vec<Attribute> {
		let mut attrs = Vec::new();
		loop {
			self.skip_ws();
			if self.peek_char() == Some('>') || self.peek_str("/>") {
				break;
			}
			let start = self.pos;
			let Some(name) = self.parse_ident() else {
				self.recover_attr();
				continue;
			};
			self.skip_ws();
			let value = if self.consume_char('=') {
				self.skip_ws();
				if self.peek_char() == Some('"') {
					match self.parse_string() {
						Some(value) => {
							let span = Span::new(start, self.pos);
							AttrValue::String(value, span)
						}
						None => AttrValue::String(String::new(), self.span_here()),
					}
				} else if self.peek_char() == Some('{') {
					match self.parse_braced_expr() {
						Some(expr) => AttrValue::Expr(expr),
						None => AttrValue::Expr(Expr::Literal(
							crate::wui::ast::Literal::Null,
							self.span_here(),
						)),
					}
				} else if let Some(lit) = self.parse_bare_literal() {
					lit
				} else {
					self.diagnostics.push(Diagnostic::new(
						"expected attribute value",
						self.span_here(),
					));
					AttrValue::Bool(true, self.span_here())
				}
			} else {
				let span = Span::new(start, self.pos);
				AttrValue::Bool(true, span)
			};
			let span = Span::new(start, self.pos);
			attrs.push(Attribute { name, value, span });
		}
		attrs
	}

	fn parse_bare_literal(&mut self) -> Option<AttrValue> {
		let start = self.pos;
		if self.peek_str("true") && self.is_delim(4) {
			self.pos += 4;
			return Some(AttrValue::Bool(true, Span::new(start, self.pos)));
		}
		if self.peek_str("false") && self.is_delim(5) {
			self.pos += 5;
			return Some(AttrValue::Bool(false, Span::new(start, self.pos)));
		}
		if self.peek_str("null") && self.is_delim(4) {
			self.pos += 4;
			return Some(AttrValue::Null(Span::new(start, self.pos)));
		}
		let mut saw_digit = false;
		let mut saw_dot = false;
		let mut i = self.pos;
		while let Some(ch) = self.peek_char_at(i) {
			if ch.is_ascii_digit() {
				saw_digit = true;
				i += ch.len_utf8();
				continue;
			}
			if ch == '.' && !saw_dot {
				saw_dot = true;
				i += ch.len_utf8();
				continue;
			}
			break;
		}
		if saw_digit {
			let slice = &self.src[self.pos..i];
			if let Ok(value) = slice.parse::<f64>() {
				self.pos = i;
				return Some(AttrValue::Number(value, Span::new(start, self.pos)));
			}
		}
		None
	}

	fn parse_text(&mut self) -> Option<Node> {
		let start = self.pos;
		let mut end = self.pos;
		while let Some(ch) = self.peek_char() {
			if ch == '<' || ch == '{' {
				break;
			}
			self.pos += ch.len_utf8();
			end = self.pos;
		}
		if end == start {
			return None;
		}
		let text = self.src[start..end].to_string();
		if text.trim().is_empty() {
			return None;
		}
		Some(Node::Text(text, Span::new(start, end)))
	}

	fn parse_expr_node(&mut self) -> Option<Expr> {
		self.parse_braced_expr()
	}

	fn parse_braced_expr(&mut self) -> Option<Expr> {
		let start = self.pos;
		if !self.consume_char('{') {
			return None;
		}
		let expr_start = self.pos;
		let mut in_string = false;
		while let Some(ch) = self.peek_char() {
			if ch == '"' {
				in_string = !in_string;
			}
			if ch == '}' && !in_string {
				break;
			}
			self.pos += ch.len_utf8();
		}
		if self.peek_char() != Some('}') {
			self.diagnostics
				.push(Diagnostic::new("unterminated expression", self.span_here()));
			return None;
		}
		let expr_end = self.pos;
		let expr_src = &self.src[expr_start..expr_end];
		self.pos += 1;
		match ExprParser::new(expr_src, expr_start).parse() {
			Ok(expr) => Some(expr),
			Err(diag) => {
				self.diagnostics.push(diag);
				self.recover_to('}');
				Some(Expr::Literal(
					crate::wui::ast::Literal::Null,
					Span::new(start, self.pos),
				))
			}
		}
	}

	fn parse_string(&mut self) -> Option<String> {
		if !self.consume_char('"') {
			return None;
		}
		let mut out = String::new();
		while let Some(ch) = self.peek_char() {
			self.pos += ch.len_utf8();
			match ch {
				'"' => return Some(out),
				'\\' => {
					let next = self.peek_char()?;
					self.pos += next.len_utf8();
					match next {
						'"' => out.push('"'),
						'\\' => out.push('\\'),
						'n' => out.push('\n'),
						_ => {
							self.diagnostics
								.push(Diagnostic::new("invalid escape", self.span_here()));
						}
					}
				}
				_ => out.push(ch),
			}
		}
		self.diagnostics
			.push(Diagnostic::new("unterminated string", self.span_here()));
		None
	}

	fn parse_ident(&mut self) -> Option<String> {
		self.skip_ws();
		let Some(first) = self.peek_char() else {
			return None;
		};
		if !(first.is_ascii_alphabetic() || first == '_' || first == ':') {
			return None;
		}
		let mut end = self.pos + first.len_utf8();
		let mut iter = self.src[self.pos + first.len_utf8()..].char_indices();
		while let Some((offset, ch)) = iter.next() {
			if ch.is_ascii_alphanumeric() || ch == '_' || ch == ':' || ch == '-' {
				end = self.pos + first.len_utf8() + offset + ch.len_utf8();
			} else {
				break;
			}
		}
		let ident = self.src[self.pos..end].to_string();
		self.pos = end;
		Some(ident)
	}

	fn recover_attr(&mut self) {
		while let Some(ch) = self.peek_char() {
			if ch.is_whitespace() || ch == '>' || ch == '/' {
				break;
			}
			self.pos += ch.len_utf8();
		}
	}

	fn recover_to(&mut self, target: char) {
		while let Some(ch) = self.peek_char() {
			self.pos += ch.len_utf8();
			if ch == target {
				break;
			}
		}
	}

	fn skip_ws(&mut self) {
		while let Some(ch) = self.peek_char() {
			if ch.is_whitespace() {
				self.pos += ch.len_utf8();
			} else {
				break;
			}
		}
	}

	fn expect_char(&mut self, ch: char) -> Option<()> {
		self.skip_ws();
		if self.consume_char(ch) {
			Some(())
		} else {
			self.diagnostics
				.push(Diagnostic::new("expected character", self.span_here()));
			None
		}
	}

	fn consume_char(&mut self, ch: char) -> bool {
		self.skip_ws();
		if self.peek_char() == Some(ch) {
			self.pos += ch.len_utf8();
			true
		} else {
			false
		}
	}

	fn peek_char(&self) -> Option<char> {
		self.src[self.pos..].chars().next()
	}

	fn peek_char_at(&self, pos: usize) -> Option<char> {
		self.src[pos..].chars().next()
	}

	fn peek_str(&self, s: &str) -> bool {
		self.src[self.pos..].starts_with(s)
	}

	fn peek_str_at(&self, s: &str, offset: usize) -> bool {
		self.src[self.pos + offset..].starts_with(s)
	}

	fn is_delim(&self, len: usize) -> bool {
		let idx = self.pos + len;
		if idx >= self.src.len() {
			return true;
		}
		match self.src[idx..].chars().next() {
			Some(ch) => !(ch.is_ascii_alphanumeric() || ch == '_' || ch == '.'),
			None => true,
		}
	}

	fn span_here(&self) -> Span {
		Span::new(self.pos, self.pos)
	}

	fn eof(&self) -> bool {
		self.pos >= self.src.len()
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn parses_simple_element() {
		let file = Parser::new("<Text value=\"hi\" />").parse();
		assert!(file.diagnostics.is_empty());
		assert_eq!(file.nodes.len(), 1);
	}

	#[test]
	fn parses_attributes_and_children() {
		let file = Parser::new("<VStack spacing=4><Text value={state.title} /></VStack>").parse();
		assert!(file.diagnostics.is_empty());
		assert_eq!(file.nodes.len(), 1);
		let Node::Element(root) = &file.nodes[0] else {
			panic!("expected element");
		};
		assert_eq!(root.name, "VStack");
		assert_eq!(root.attrs.len(), 1);
		match &root.attrs[0].value {
			AttrValue::Number(value, _) => assert_eq!(*value, 4.0),
			_ => panic!("expected number attribute"),
		}
		assert_eq!(root.children.len(), 1);
		let Node::Element(child) = &root.children[0] else {
			panic!("expected child element");
		};
		assert_eq!(child.name, "Text");
		match &child.attrs[0].value {
			AttrValue::Expr(Expr::Path(parts, _)) => {
				assert_eq!(parts, &vec!["state".to_string(), "title".to_string()]);
			}
			_ => panic!("expected path expression"),
		}
	}

	#[test]
	fn reports_mismatched_closing_tag() {
		let file = Parser::new("<Text></Button>").parse();
		assert!(!file.diagnostics.is_empty());
	}
}
</file>

<file path="wgui/src/dist.rs">
pub fn index_html() -> &'static str {
	include_str!("../../dist/index.html")
}

pub fn index_js() -> &'static str {
	include_str!("../../dist/index.js")
}

pub fn index_css() -> &'static str {
	include_str!("../../dist/index.css")
}
</file>

<file path="wgui/src/ssr.rs">
use crate::gui::{FlexDirection, Item, ItemPayload, Layout, SelectOption};

pub fn render_document(item: &Item) -> String {
	let mut out = String::new();
	out.push_str("<html><head>");
	out.push_str("<title></title>");
	out.push_str(
		"<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\" />",
	);
	out.push_str("<link rel=\"stylesheet\" href=\"/index.css\"></link>");
	out.push_str("</head>");
	out.push_str("<body style=\"display:flex;flex-direction:row;\">");
	out.push_str("<div id=\"wgui-root\">");
	out.push_str(&render_item(item));
	out.push_str("</div>");
	out.push_str("<script src=\"/index.js\"></script>");
	out.push_str("</body></html>");
	out
}

pub fn render_item(item: &Item) -> String {
	match &item.payload {
		ItemPayload::Layout(layout) => render_layout(item, layout),
		ItemPayload::Text { value } => render_text(item, value),
		ItemPayload::TextInput { value, placeholder } => render_text_input(item, value, placeholder),
		ItemPayload::Textarea { value, placeholder } => render_textarea(item, value, placeholder),
		ItemPayload::Select { value, options } => render_select(item, value, options),
		ItemPayload::Checkbox { checked } => render_checkbox(item, *checked),
		ItemPayload::Slider { min, max, value, step } => render_slider(item, *min, *max, *value, *step),
		ItemPayload::Button { title } => render_button(item, title),
		ItemPayload::Table { items } => render_table(item, items),
		ItemPayload::Thead { items } => render_section(item, "thead", items),
		ItemPayload::Tbody { items } => render_section(item, "tbody", items),
		ItemPayload::Tr { items } => render_section(item, "tr", items),
		ItemPayload::Th { item: cell } => render_cell(item, "th", cell),
		ItemPayload::Td { item: cell } => render_cell(item, "td", cell),
		ItemPayload::Img { src, alt, object_fit } => render_image(item, src, alt, object_fit.as_deref()),
		ItemPayload::FolderPicker => render_folder_picker(item),
		ItemPayload::FloatingLayout { x, y, width, height } => {
			render_floating_layout(item, *x, *y, *width, *height)
		}
		ItemPayload::Modal { body, open } => render_modal(item, body, *open),
		ItemPayload::None => String::new(),
	}
}

fn render_layout(item: &Item, layout: &Layout) -> String {
	let mut style = StyleBuilder::new();
	style.push("display", "flex");
	style.push("flex-direction", match layout.flex {
		FlexDirection::Row => "row",
		FlexDirection::Column => "column",
	});
	if layout.spacing > 0 {
		style.push("gap", &format!("{}px", layout.spacing));
	}
	if layout.wrap {
		style.push("flex-wrap", "wrap");
	}
	apply_item_styles(item, &mut style);
	let mut classes = vec!["retro-panel".to_string()];
	classes.push(match layout.flex {
		FlexDirection::Row => "flex-row".to_string(),
		FlexDirection::Column => "flex-col".to_string(),
	});
	if layout.wrap {
		classes.push("flex-wrap".to_string());
	}
	let attrs = collect_item_attrs(item);
	let children = render_children(&layout.body);
	render_element("div", &classes, style, &attrs, &children)
}

fn render_text(item: &Item, value: &str) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-text".to_string()];
	let attrs = collect_item_attrs(item);
	render_element("span", &classes, style, &attrs, &escape_text(value))
}

fn render_text_input(item: &Item, value: &str, placeholder: &str) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-input".to_string()];
	let mut attrs = collect_item_attrs(item);
	attrs.push(("type".to_string(), "text".to_string()));
	attrs.push(("value".to_string(), escape_attr(value)));
	if !placeholder.is_empty() {
		attrs.push(("placeholder".to_string(), escape_attr(placeholder)));
	}
	render_void_element("input", &classes, style, &attrs)
}

fn render_textarea(item: &Item, value: &str, placeholder: &str) -> String {
	let mut style = StyleBuilder::new();
	style.push("resize", "none");
	style.push("overflow-y", "hidden");
	style.push("min-height", "20px");
	style.push("line-height", "20px");
	let row_count = value.split('\n').count().max(1);
	style.push("height", &format!("{}px", row_count * 20));
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-input".to_string()];
	let mut attrs = collect_item_attrs(item);
	if !placeholder.is_empty() {
		attrs.push(("placeholder".to_string(), escape_attr(placeholder)));
	}
	render_element("textarea", &classes, style, &attrs, &escape_text(value))
}

fn render_select(item: &Item, value: &str, options: &[SelectOption]) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-input".to_string()];
	let mut children = String::new();
	for option in options {
		let mut attrs = Vec::new();
		attrs.push(("value".to_string(), escape_attr(option.value())));
		if option.value() == value {
			attrs.push(("selected".to_string(), "selected".to_string()));
		}
		children.push_str(&render_element(
			"option",
			&[],
			StyleBuilder::new(),
			&attrs,
			&escape_text(option.name()),
		));
	}
	let attrs = collect_item_attrs(item);
	render_element("select", &classes, style, &attrs, &children)
}

fn render_checkbox(item: &Item, checked: bool) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-checkbox".to_string()];
	let mut attrs = collect_item_attrs(item);
	attrs.push(("type".to_string(), "checkbox".to_string()));
	if checked {
		attrs.push(("checked".to_string(), "checked".to_string()));
	}
	render_void_element("input", &classes, style, &attrs)
}

fn render_slider(item: &Item, min: i32, max: i32, value: i32, step: i32) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-input".to_string()];
	let mut attrs = collect_item_attrs(item);
	attrs.extend(vec![
		("type".to_string(), "range".to_string()),
		("min".to_string(), min.to_string()),
		("max".to_string(), max.to_string()),
		("value".to_string(), value.to_string()),
		("step".to_string(), step.to_string()),
	]);
	render_void_element("input", &classes, style, &attrs)
}

fn render_button(item: &Item, title: &str) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-button".to_string()];
	let attrs = collect_item_attrs(item);
	render_element("button", &classes, style, &attrs, &escape_text(title))
}

fn render_table(item: &Item, items: &[Item]) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-table".to_string()];
	let attrs = collect_item_attrs(item);
	let children = render_children(items);
	render_element("table", &classes, style, &attrs, &children)
}

fn render_section(item: &Item, tag: &str, items: &[Item]) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let attrs = collect_item_attrs(item);
	let children = render_children(items);
	render_element(tag, &[], style, &attrs, &children)
}

fn render_cell(item: &Item, tag: &str, child: &Item) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let attrs = collect_item_attrs(item);
	let child_html = render_item(child);
	render_element(tag, &[], style, &attrs, &child_html)
}

fn render_image(item: &Item, src: &str, alt: &str, object_fit: Option<&str>) -> String {
	let mut style = StyleBuilder::new();
	style.push("max-width", "100%");
	style.push("max-height", "100%");
	if let Some(fit) = object_fit {
		style.push("object-fit", fit);
	} else {
		style.push("object-fit", "contain");
	}
	apply_item_styles(item, &mut style);
	let classes = vec!["retro-panel".to_string()];
	let mut attrs = collect_item_attrs(item);
	attrs.push(("src".to_string(), escape_attr(src)));
	attrs.push(("alt".to_string(), escape_attr(alt)));
	attrs.push(("loading".to_string(), "lazy".to_string()));
	render_void_element("img", &classes, style, &attrs)
}

fn render_folder_picker(item: &Item) -> String {
	let mut style = StyleBuilder::new();
	apply_item_styles(item, &mut style);
	let mut attrs = collect_item_attrs(item);
	attrs.extend(vec![
		("type".to_string(), "file".to_string()),
		("webkitdirectory".to_string(), "true".to_string()),
	]);
	render_void_element("input", &[], style, &attrs)
}

fn render_floating_layout(item: &Item, x: u32, y: u32, width: u32, height: u32) -> String {
	let mut style = StyleBuilder::new();
	style.push("position", "absolute");
	style.push("left", &format!("{}px", x));
	style.push("top", &format!("{}px", y));
	style.push("width", &format!("{}px", width));
	style.push("height", &format!("{}px", height));
	apply_item_styles(item, &mut style);
	let attrs = collect_item_attrs(item);
	render_element("div", &[], style, &attrs, "")
}

fn render_modal(item: &Item, body: &[Item], open: bool) -> String {
	let mut style = StyleBuilder::new();
	style.push("position", "fixed");
	style.push("left", "0");
	style.push("top", "0");
	style.push("width", "100vw");
	style.push("height", "100vh");
	style.push("display", if open { "flex" } else { "none" });
	style.push("align-items", "center");
	style.push("justify-content", "center");
	style.push("padding", "32px");
	style.push("box-sizing", "border-box");
	style.push("background-color", "rgba(0, 0, 0, 0.45)");
	style.push("backdrop-filter", "blur(2px)");
	style.push("z-index", "1000");
	style.push("pointer-events", if open { "auto" } else { "none" });
	apply_item_styles(item, &mut style);
	let children = render_children(body);
	let mut attrs = collect_item_attrs(item);
	attrs.extend(vec![
		("data-modal".to_string(), "overlay".to_string()),
		("role".to_string(), "dialog".to_string()),
		("aria-modal".to_string(), "true".to_string()),
		("aria-hidden".to_string(), if open { "false".to_string() } else { "true".to_string() }),
	]);
	render_element("div", &[], style, &attrs, &children)
}

fn render_children(items: &[Item]) -> String {
	let mut out = String::new();
	for item in items {
		out.push_str(&render_item(item));
	}
	out
}

fn render_element(
	tag: &str,
	classes: &[String],
	style: StyleBuilder,
	attrs: &[(String, String)],
	children: &str,
) -> String {
	let mut out = String::new();
	out.push('<');
	out.push_str(tag);
	out.push_str(&render_attributes(classes, style, attrs));
	out.push('>');
	out.push_str(children);
	out.push_str("</");
	out.push_str(tag);
	out.push('>');
	out
}

fn render_void_element(
	tag: &str,
	classes: &[String],
	style: StyleBuilder,
	attrs: &[(String, String)],
) -> String {
	let mut out = String::new();
	out.push('<');
	out.push_str(tag);
	out.push_str(&render_attributes(classes, style, attrs));
	out.push_str(" />");
	out
}

fn render_attributes(
	classes: &[String],
	style: StyleBuilder,
	attrs: &[(String, String)],
) -> String {
	let mut out = String::new();
	if !classes.is_empty() {
		out.push_str(" class=\"");
		out.push_str(&classes.join(" "));
		out.push('"');
	}
	if let Some(style_value) = style.build() {
		out.push_str(" style=\"");
		out.push_str(&escape_attr(&style_value));
		out.push('"');
	}
	for (name, value) in attrs {
		out.push(' ');
		out.push_str(name);
		out.push_str("=\"");
		out.push_str(&escape_attr(value));
		out.push('"');
	}
	out
}

fn apply_item_styles(item: &Item, style: &mut StyleBuilder) {
	if item.width > 0 {
		style.push("width", &format!("{}px", item.width));
	}
	if item.height > 0 {
		style.push("height", &format!("{}px", item.height));
	}
	if item.min_width > 0 {
		style.push("min-width", &format!("{}px", item.min_width));
	}
	if item.max_width > 0 {
		style.push("max-width", &format!("{}px", item.max_width));
	}
	if item.min_height > 0 {
		style.push("min-height", &format!("{}px", item.min_height));
	}
	if item.max_height > 0 {
		style.push("max-height", &format!("{}px", item.max_height));
	}
	if item.grow > 0 {
		style.push("flex-grow", &item.grow.to_string());
	}
	if !item.background_color.is_empty() {
		style.push("background-color", &item.background_color);
	}
	if !item.text_align.is_empty() {
		style.push("text-align", &item.text_align);
	}
	if !item.cursor.is_empty() {
		style.push("cursor", &item.cursor);
	}
	if item.margin > 0 {
		style.push("margin", &format!("{}px", item.margin));
	}
	if item.margin_left > 0 {
		style.push("margin-left", &format!("{}px", item.margin_left));
	}
	if item.margin_right > 0 {
		style.push("margin-right", &format!("{}px", item.margin_right));
	}
	if item.margin_top > 0 {
		style.push("margin-top", &format!("{}px", item.margin_top));
	}
	if item.margin_bottom > 0 {
		style.push("margin-bottom", &format!("{}px", item.margin_bottom));
	}
	if item.padding > 0 {
		style.push("padding", &format!("{}px", item.padding));
	}
	if item.padding_left > 0 {
		style.push("padding-left", &format!("{}px", item.padding_left));
	}
	if item.padding_right > 0 {
		style.push("padding-right", &format!("{}px", item.padding_right));
	}
	if item.padding_top > 0 {
		style.push("padding-top", &format!("{}px", item.padding_top));
	}
	if item.padding_bottom > 0 {
		style.push("padding-bottom", &format!("{}px", item.padding_bottom));
	}
	if !item.border.is_empty() {
		style.push("border", &item.border);
	}
	if !item.overflow.is_empty() {
		style.push("overflow", &item.overflow);
	}
}

fn collect_item_attrs(item: &Item) -> Vec<(String, String)> {
	let mut attrs = Vec::new();
	if item.editable {
		attrs.push(("contenteditable".to_string(), "true".to_string()));
	}
	attrs
}

fn escape_text(input: &str) -> String {
	input
		.replace('&', "&amp;")
		.replace('<', "&lt;")
		.replace('>', "&gt;")
}

fn escape_attr(input: &str) -> String {
	input
		.replace('&', "&amp;")
		.replace('<', "&lt;")
		.replace('>', "&gt;")
		.replace('"', "&quot;")
		.replace('\'', "&#39;")
}

struct StyleBuilder {
	entries: Vec<String>,
}

impl StyleBuilder {
	fn new() -> Self {
		Self { entries: Vec::new() }
	}

	fn push(&mut self, name: &str, value: &str) {
		if value.is_empty() {
			return;
		}
		self.entries.push(format!("{}:{}", name, value));
	}

	fn build(self) -> Option<String> {
		if self.entries.is_empty() {
			None
		} else {
			Some(self.entries.join(";"))
		}
	}
}
</file>

<file path=".editorconfig">
[*]
tab_width = 4
indent_style = tab
indent_size = 4
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
The workspace root (`Cargo.toml`) ties together the core `wgui` crate and the `examples/*` showcase projects. Core server-side virtual DOM logic lives in `wgui/src` (notably `gui.rs`, `server.rs`, `diff.rs`), with focused unit tests colocated under `#[cfg(test)]`. Browser-facing TypeScript resides in `ts/` and is bundled into `dist/index.js`; treat everything under `dist/` as generated output. Example applications such as `examples/todo` and `examples/allcomponents` exercise the library and ship any static assets they need.

## Build, Test, and Development Commands
- `cargo build`  compile all workspace crates to validate Rust changes.
- `cargo test -p wgui`  run the unit tests embedded in the core crate; add `-- --nocapture` when debugging logs.
- `cargo run -p todo`  launch the Todo example and verify end-to-end behaviour.
- `bun build ./ts/app.ts --outfile ./dist/index.js`  produce the browser bundle once; add `--watch` or call `bundle_watch.sh`/`.bat` for iterative work.
- `bunx tsc ./ts/* --noEmit --allowImportingTsExtensions`  type-check the front-end exactly as documented in `readme.md`.

## Coding Style & Naming Conventions
Editors should honour `.editorconfig` (tabs with a visual width of four). Run `cargo fmt` before committing Rust changes to normalize spacing, and prefer `snake_case` for functions/modules and `PascalCase` for types. TypeScript sticks to camelCase identifiers, PascalCase classes, and omits trailing semicolons; keep imports relative with explicit `.ts` extensions. Avoid manual edits in `dist/`; adjust `ts/` sources and re-run the bundler instead.

## Testing Guidelines
Add Rust tests alongside the modules they exercise, mirroring the existing `#[cfg(test)]` blocks in `diff.rs` and friends. Run `cargo test -p wgui` before every push, and consider `cargo test -p <example>` when modifying shared behaviour that examples rely on. The front-end currently lacks automated tests, so rely on `bunx tsc` plus live browser verification via the running example applications.

## Commit & Pull Request Guidelines
Recent commits use short, imperative messages in lowercase (e.g., `making folder picker`); follow that tone and scope. Squash trivial fixups locally, and include a brief summary of the affected module(s) in the body when needed. Pull requests should describe user-visible changes, list the commands you ran (`cargo test`, `bun build`), and link to any relevant issues or screenshots that help reviewers.
</file>

<file path="bundle_watch.bat">
bun build ./ts/app.ts --watch --outfile ./dist/index.js
</file>

<file path="bundle_watch.sh">
bun build ./ts/app.ts --watch --outfile ./dist/index.js
</file>

<file path="rustfmt.toml">
hard_tabs = true
tab_spaces = 4
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2016",                
    "module": "commonjs",                          
    "esModuleInterop": true,                            
    "forceConsistentCasingInFileNames": true,          
    "strict": true,                                 
    "skipLibCheck": true,
	"outDir": "./dist",
	"allowImportingTsExtensions":true,
	"emitDeclarationOnly": false,
	"noEmit": true
  },
  "include": ["src/**/*"]
}
</file>

<file path="examples/allcomponents/Cargo.toml">
[package]
name = "allcomponents"
version = "0.1.0"
edition = "2021"

[dependencies]
wgui = { path = "../../wgui", features = ["hyper"] }
tokio = { version = "1", features = ["full"] }
simple_logger = "4"
log = "0.4"
</file>

<file path="examples/axum/src/main.rs">
use axum::Router;
use log::Level;
use std::{collections::HashSet, net::SocketAddr, sync::Arc};
use tokio::sync::Mutex;
use wgui::{ClientEvent, Item, Wgui};

#[derive(Default)]
struct UiState {
	client_ids: HashSet<usize>,
	count: i32,
}

#[tokio::main]
async fn main() {
	simple_logger::init_with_level(Level::Info).unwrap();

	let mut wgui = Wgui::new_without_server();
	let handle = wgui.handle();
	let router = wgui.router();
	let ui_state = Arc::new(Mutex::new(UiState::default()));

	tokio::spawn({
		let ui_state = ui_state.clone();
		let render_handle = handle.clone();
		async move {
			while let Some(event) = wgui.next().await {
				match event {
					ClientEvent::Connected { id } => {
						let count = {
							let mut state = ui_state.lock().await;
							state.client_ids.insert(id);
							state.count
						};
						render_handle.render(id, render_counter(count)).await;
					}
					ClientEvent::Disconnected { id } => {
						ui_state.lock().await.client_ids.remove(&id);
					}
					ClientEvent::OnClick(_) => {
						let (count, ids) = {
							let mut state = ui_state.lock().await;
							state.count += 1;
							(
								state.count,
								state.client_ids.iter().copied().collect::<Vec<_>>(),
							)
						};
						for id in ids {
							render_handle.render(id, render_counter(count)).await;
						}
					}
					_ => {}
				}
			}
		}
	});

	let app = Router::new().merge(router);

	let addr: SocketAddr = "0.0.0.0:4001".parse().unwrap();
	log::info!("listening on http://localhost:4001");

	let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
	axum::serve(listener, app).await.unwrap();
}

fn render_counter(count: i32) -> Item {
	let label = format!("Count: {}", count);
	wgui::vstack([
		wgui::img(
			"https://images.unsplash.com/photo-1524678606370-a47ad25cb82a?auto=format&fit=crop&w=600&q=60",
			"Sample space"
		)
		.width(360)
		.height(210)
		.object_fit("cover"),
		wgui::text(&label).margin_bottom(4),
		wgui::button("+1").id(1),
	])
}
</file>

<file path="examples/axum/Cargo.toml">
[package]
name = "axum_example"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1"
axum = { workspace = true }
futures-util = "0.3"
log = "0.4"
serde = { version = "1", features = ["derive"] }
simple_logger = "4"
tokio = { version = "1", features = ["full"] }
wgui = { path = "../../wgui", default-features = false, features = ["axum"] }
</file>

<file path="examples/todo_wui/src/generated/todo_gen.rs">
use wgui::*;

pub enum Action {
	EditNewTodo { value: String },
	AddTodo,
	ToggleTodo { arg: u32 },
}

pub fn decode(event: &wgui::ClientEvent) -> Option<Action> {
	match event {
		wgui::ClientEvent::OnTextChanged(ev) if ev.id == 1342686741 => Some(Action::EditNewTodo { value: ev.value.clone() }),
		wgui::ClientEvent::OnClick(ev) if ev.id == 3063551964 => Some(Action::AddTodo),
		wgui::ClientEvent::OnClick(ev) if ev.id == 1241325501 => ev.inx.map(|arg| Action::ToggleTodo { arg }),
		_ => None,
	}
}

pub fn render(state: &crate::TodoState) -> Item {
	let mut children = Vec::new();
	children.push({
		let mut items = Vec::new();
		items.push(wgui::text("Todo List"));
		items.push({
			let mut items = Vec::new();
			items.push(wgui::text_input().svalue(&state.new_todo_name).placeholder("What needs to be done?").id(1342686741));
			items.push(wgui::button("Add").id(3063551964));
			wgui::hstack(items)
			}.spacing(4));
		items.push({
			let mut items = Vec::new();
			for (i, item) in state.items.iter().enumerate() {
				items.push({
					let mut items = Vec::new();
					items.push(wgui::checkbox().checked(item.completed).id(1241325501).inx(item.id));
					items.push(wgui::text(&item.name));
					wgui::hstack(items)
					}.spacing(4));
			}
			wgui::vstack(items)
			}.spacing(4));
		wgui::vstack(items)
		}.spacing(8).padding(10));
	wgui::vstack(children)
}
</file>

<file path="examples/todo_wui/build.rs">
use std::fs;
use std::path::Path;

fn main() {
	let input_dir = Path::new("wui/pages");
	let output_dir = Path::new("src/generated");

	println!("cargo:rerun-if-changed=wui/pages");

	if !input_dir.exists() {
		panic!("wui input directory not found: {}", input_dir.display());
	}
	if let Err(err) = fs::create_dir_all(output_dir) {
		panic!(
			"failed to create output dir {}: {}",
			output_dir.display(),
			err
		);
	}

	let mut routes = Vec::new();
	let mut modules = Vec::new();
	let entries = fs::read_dir(input_dir).expect("failed to read wui/pages");

	for entry in entries.flatten() {
		let path = entry.path();
		if path.extension().and_then(|ext| ext.to_str()) != Some("wui") {
			continue;
		}
		println!("cargo:rerun-if-changed={}", path.display());
		let module_name = path
			.file_stem()
			.and_then(|stem| stem.to_str())
			.unwrap_or("page")
			.to_string();
		let source = fs::read_to_string(&path)
			.unwrap_or_else(|err| panic!("failed to read {}: {}", path.display(), err));
		let result = wgui::wui::compiler::compile(&source, &module_name);
		let mut generated = match result {
			Ok(gen) => gen,
			Err(diags) => {
				let mut message = format!("failed to compile {}:\n", path.display());
				for diag in diags {
					message.push_str(&format!(
						" - {} at {}..{}\n",
						diag.message, diag.span.start, diag.span.end
					));
				}
				panic!("{}", message);
			}
		};
		for (module, route) in generated.routes.drain(..) {
			routes.push((module, route));
		}
		let out_path = output_dir.join(format!("{}_gen.rs", module_name));
		fs::write(&out_path, generated.code)
			.unwrap_or_else(|err| panic!("failed to write {}: {}", out_path.display(), err));
		modules.push(module_name);
	}

	write_mod_rs(output_dir, &modules);
	write_routes(output_dir, &routes);
}

fn write_mod_rs(dir: &Path, modules: &[String]) {
	let mut contents = String::new();
	for module in modules {
		contents.push_str(&format!("pub mod {}_gen;\n", module));
	}
	let out_path = dir.join("mod.rs");
	fs::write(&out_path, contents)
		.unwrap_or_else(|err| panic!("failed to write {}: {}", out_path.display(), err));
}

fn write_routes(dir: &Path, routes: &[(String, String)]) {
	let mut contents = String::new();
	contents.push_str(
		"pub struct RouteDef {\n\tpub module: &'static str,\n\tpub route: &'static str,\n}\n\n",
	);
	contents.push_str("pub const ROUTES: &[RouteDef] = &[\n");
	for (module, route) in routes {
		contents.push_str(&format!(
			"\tRouteDef {{ module: \"{}\", route: \"{}\" }},\n",
			module, route
		));
	}
	contents.push_str("];\n");
	let out_path = dir.join("routes.gen.rs");
	fs::write(&out_path, contents)
		.unwrap_or_else(|err| panic!("failed to write {}: {}", out_path.display(), err));
}
</file>

<file path="wgui/src/wui/compiler/codegen.rs">
use crate::wui::ast::{BinaryOp, Expr, Literal, UnaryOp};
use crate::wui::compiler::ir::{
	ActionDef, ActionPayload, EventKind, IrDocument, IrFor, IrIf, IrNode, IrProp, IrScope, IrWidget,
};

pub fn generate(doc: &IrDocument) -> String {
	let mut out = String::new();
	out.push_str("use wgui::*;\n\n");
	out.push_str("pub enum Action {\n");
	for action in &doc.actions {
		out.push_str(&format!(
			"\t{}{},\n",
			action_variant(&action.name),
			action_payload(action)
		));
	}
	out.push_str("}\n\n");
	out.push_str("pub fn decode(event: &wgui::ClientEvent) -> Option<Action> {\n");
	out.push_str("\tmatch event {\n");
	for action in &doc.actions {
		out.push_str(&decode_arm(action));
	}
	out.push_str("\t\t_ => None,\n\t}\n}\n\n");
	let state_type = doc
		.pages
		.first()
		.and_then(|page| page.state_type.clone())
		.unwrap_or_else(|| "State".to_string());
	let state_type_path = state_type_path(&state_type);
	out.push_str(&format!(
		"pub fn render(state: &{}) -> Item {{\n",
		state_type_path
	));
	out.push_str(&emit_nodes(&doc.nodes, 1));
	out.push_str("}\n");
	out
}

fn action_payload(action: &ActionDef) -> String {
	match action.payload {
		ActionPayload::None => String::new(),
		ActionPayload::U32 => " { arg: u32 }".to_string(),
		ActionPayload::String => " { value: String }".to_string(),
		ActionPayload::I32 => " { value: i32 }".to_string(),
	}
}

fn decode_arm(action: &ActionDef) -> String {
	let variant = action_variant(&action.name);
	let id = action.id;
	match action.kind {
		EventKind::Click => match action.payload {
			ActionPayload::None => format!(
				"\t\twgui::ClientEvent::OnClick(ev) if ev.id == {id} => Some(Action::{variant}),\n"
			),
			ActionPayload::U32 => format!(
				"\t\twgui::ClientEvent::OnClick(ev) if ev.id == {id} => ev.inx.map(|arg| Action::{variant} {{ arg }}),\n"
			),
			_ => String::new(),
		},
		EventKind::TextChanged => format!(
			"\t\twgui::ClientEvent::OnTextChanged(ev) if ev.id == {id} => Some(Action::{variant} {{ value: ev.value.clone() }}),\n"
		),
		EventKind::SliderChange => format!(
			"\t\twgui::ClientEvent::OnSliderChange(ev) if ev.id == {id} => Some(Action::{variant} {{ value: ev.value }}),\n"
		),
		EventKind::Select => format!(
			"\t\twgui::ClientEvent::OnSelect(ev) if ev.id == {id} => Some(Action::{variant} {{ value: ev.value.clone() }}),\n"
		),
	}
}

fn emit_nodes(nodes: &[IrNode], indent: usize) -> String {
	let mut out = String::new();
	let indent_str = "\t".repeat(indent);
	out.push_str(&format!("{indent_str}let mut children = Vec::new();\n"));
	for node in nodes {
		out.push_str(&emit_node_into(node, indent, "children"));
	}
	out.push_str(&format!("{indent_str}wgui::vstack(children)\n"));
	out
}

fn emit_node_into(node: &IrNode, indent: usize, target: &str) -> String {
	let indent_str = "\t".repeat(indent);
	match node {
		IrNode::Widget(widget) => {
			let rendered = emit_widget(widget, indent + 1);
			format!("{indent_str}{target}.push({rendered});\n")
		}
		IrNode::Text(text) => format!("{indent_str}{target}.push(wgui::text({:?}));\n", text),
		IrNode::For(for_node) => emit_for(for_node, indent, target),
		IrNode::If(if_node) => emit_if(if_node, indent, target),
		IrNode::Scope(scope) => emit_scope(scope, indent, target),
	}
}

fn emit_for(node: &IrFor, indent: usize, target: &str) -> String {
	let indent_str = "\t".repeat(indent);
	let mut out = String::new();
	let list_expr = emit_expr(&node.each);
	let item = &node.item;
	if let Some(index) = &node.index {
		out.push_str(&format!(
			"{indent_str}for ({index}, {item}) in {list_expr}.iter().enumerate() {{\n"
		));
	} else {
		out.push_str(&format!(
			"{indent_str}for {item} in {list_expr}.iter() {{\n"
		));
	}
	out.push_str(&emit_body(&node.body, indent + 1, target));
	out.push_str(&format!("{indent_str}}}\n"));
	out
}

fn emit_if(node: &IrIf, indent: usize, target: &str) -> String {
	let indent_str = "\t".repeat(indent);
	let mut out = String::new();
	let test = emit_expr(&node.test);
	out.push_str(&format!("{indent_str}if {test} {{\n"));
	out.push_str(&emit_body(&node.then_body, indent + 1, target));
	out.push_str(&format!("{indent_str}}}"));
	if !node.else_body.is_empty() {
		out.push_str(" else {\n");
		out.push_str(&emit_body(&node.else_body, indent + 1, target));
		out.push_str(&format!("{indent_str}}}\n"));
	} else {
		out.push('\n');
	}
	out
}

fn emit_scope(node: &IrScope, indent: usize, target: &str) -> String {
	emit_body(&node.body, indent, target)
}

fn emit_body(nodes: &[IrNode], indent: usize, target: &str) -> String {
	let mut out = String::new();
	for node in nodes {
		out.push_str(&emit_node_into(node, indent, target));
	}
	out
}

fn emit_widget(widget: &IrWidget, indent: usize) -> String {
	let mut base = match widget.tag.as_str() {
		"VStack" => emit_container("vstack", &widget.children, indent),
		"HStack" => emit_container("hstack", &widget.children, indent),
		"Text" => emit_text(widget),
		"Button" => emit_textual("button", widget, "text"),
		"TextInput" => "wgui::text_input()".to_string(),
		"Checkbox" => "wgui::checkbox()".to_string(),
		"Slider" => "wgui::slider()".to_string(),
		"Image" => emit_image(widget),
		_ => "wgui::text(\"unsupported\")".to_string(),
	};
	for prop in &widget.props {
		if !should_emit_prop(&widget.tag, prop) {
			continue;
		}
		base = format!("{}.{}", base, emit_prop(prop));
	}
	base
}

fn emit_container(kind: &str, children: &[IrNode], indent: usize) -> String {
	let mut out = String::new();
	let indent_str = "\t".repeat(indent);
	out.push_str("{\n");
	out.push_str(&format!("{indent_str}let mut items = Vec::new();\n"));
	for node in children {
		out.push_str(&emit_container_child(node, indent, "items"));
	}
	out.push_str(&format!("{indent_str}wgui::{kind}(items)\n"));
	out.push_str(&format!("{indent_str}}}"));
	out
}

fn emit_container_child(node: &IrNode, indent: usize, target: &str) -> String {
	emit_node_into(node, indent, target)
}

fn emit_text(widget: &IrWidget) -> String {
	for prop in &widget.props {
		if let IrProp::Literal { name, value } = prop {
			if name == "value" {
				return format!("wgui::text({:?})", value);
			}
		}
		if let IrProp::Value { name, expr } = prop {
			if name == "value" {
				return format!("wgui::text({})", emit_string_expr(expr));
			}
		}
	}
	"wgui::text(\"\")".to_string()
}

fn emit_textual(kind: &str, widget: &IrWidget, prop_name: &str) -> String {
	for prop in &widget.props {
		if let IrProp::Literal { name, value } = prop {
			if name == prop_name {
				return format!("wgui::{kind}({:?})", value);
			}
		}
		if let IrProp::Value { name, expr } = prop {
			if name == prop_name {
				return format!("wgui::{kind}({})", emit_string_expr(expr));
			}
		}
	}
	format!("wgui::{kind}(\"\")")
}

fn emit_image(widget: &IrWidget) -> String {
	let mut src = "\"\"".to_string();
	let mut alt = "\"\"".to_string();
	for prop in &widget.props {
		match prop {
			IrProp::Literal { name, value } if name == "src" => src = format!("{:?}", value),
			IrProp::Value { name, expr } if name == "src" => src = emit_string_expr(expr),
			IrProp::Literal { name, value } if name == "alt" => alt = format!("{:?}", value),
			IrProp::Value { name, expr } if name == "alt" => alt = emit_string_expr(expr),
			_ => {}
		}
	}
	format!("wgui::img({src}, {alt})")
}

fn emit_prop(prop: &IrProp) -> String {
	match prop {
		IrProp::Literal { name, value } => format!("{}({:?})", prop_method(name), value),
		IrProp::Number { name, value } => emit_number_prop(name, *value),
		IrProp::Bool { name, value } => format!("{}({})", prop_method(name), value),
		IrProp::Value { name, expr } => match name.as_str() {
			"svalue" => format!("svalue({})", emit_string_expr(expr)),
			"ivalue" => format!("ivalue({})", emit_expr(expr)),
			"checked" => format!("checked({})", emit_expr(expr)),
			_ if is_string_prop(name) => {
				format!("{}({})", prop_method(name), emit_string_expr(expr))
			}
			_ => format!("{}({})", prop_method(name), emit_expr(expr)),
		},
		IrProp::Bind { name, expr } => match name.as_str() {
			"bind:svalue" => format!("svalue({})", emit_string_expr(expr)),
			"bind:ivalue" => format!("ivalue({})", emit_expr(expr)),
			"bind:checked" => format!("checked({})", emit_expr(expr)),
			_ => String::new(),
		},
		IrProp::Event { action, arg, .. } => {
			let mut base = format!("id({})", action_id(action));
			if let Some(expr) = arg {
				base = format!("{base}.inx({})", emit_expr(expr));
			}
			base
		}
	}
}

fn emit_number_prop(name: &str, value: f64) -> String {
	match name {
		"min" | "max" | "step" | "ivalue" => format!("{}({})", prop_method(name), value as i32),
		"padding" | "paddingLeft" | "paddingRight" | "paddingTop" | "paddingBottom" | "margin"
		| "marginLeft" | "marginRight" | "marginTop" | "marginBottom" => {
			format!("{}({})", prop_method(name), value as u16)
		}
		_ => format!("{}({})", prop_method(name), value as u32),
	}
}

fn prop_method(name: &str) -> String {
	match name {
		"ivalue" => "ivalue".to_string(),
		"spacing" => "spacing".to_string(),
		"padding" => "padding".to_string(),
		"paddingLeft" => "padding_left".to_string(),
		"paddingRight" => "padding_right".to_string(),
		"paddingTop" => "padding_top".to_string(),
		"paddingBottom" => "padding_bottom".to_string(),
		"margin" => "margin".to_string(),
		"marginLeft" => "margin_left".to_string(),
		"marginRight" => "margin_right".to_string(),
		"marginTop" => "margin_top".to_string(),
		"marginBottom" => "margin_bottom".to_string(),
		"backgroundColor" => "background_color".to_string(),
		"border" => "border".to_string(),
		"width" => "width".to_string(),
		"height" => "height".to_string(),
		"minWidth" => "min_width".to_string(),
		"maxWidth" => "max_width".to_string(),
		"minHeight" => "min_height".to_string(),
		"maxHeight" => "max_height".to_string(),
		"grow" => "grow".to_string(),
		"textAlign" => "text_align".to_string(),
		"cursor" => "cursor".to_string(),
		"wrap" => "wrap".to_string(),
		"overflow" => "overflow".to_string(),
		"placeholder" => "placeholder".to_string(),
		"objectFit" => "object_fit".to_string(),
		"min" => "min".to_string(),
		"max" => "max".to_string(),
		"step" => "step".to_string(),
		_ => name.to_string(),
	}
}

fn emit_expr(expr: &Expr) -> String {
	match expr {
		Expr::Literal(lit, _) => match lit {
			Literal::String(s) => format!("{:?}", s),
			Literal::Number(n) => format!("{}", n),
			Literal::Bool(b) => format!("{}", b),
			Literal::Null => "None".to_string(),
		},
		Expr::Path(parts, _) => parts.join("."),
		Expr::Unary { op, expr, .. } => match op {
			UnaryOp::Not => format!("!{}", emit_expr(expr)),
			UnaryOp::Neg => format!("-{}", emit_expr(expr)),
		},
		Expr::Binary {
			left, op, right, ..
		} => {
			let op_str = match op {
				BinaryOp::Add => "+",
				BinaryOp::Sub => "-",
				BinaryOp::Mul => "*",
				BinaryOp::Div => "/",
				BinaryOp::Mod => "%",
				BinaryOp::Eq => "==",
				BinaryOp::Neq => "!=",
				BinaryOp::Lt => "<",
				BinaryOp::Lte => "<=",
				BinaryOp::Gt => ">",
				BinaryOp::Gte => ">=",
				BinaryOp::And => "&&",
				BinaryOp::Or => "||",
			};
			format!("({} {} {})", emit_expr(left), op_str, emit_expr(right))
		}
		Expr::Ternary {
			cond,
			then_expr,
			else_expr,
			..
		} => format!(
			"if {} {{ {} }} else {{ {} }}",
			emit_expr(cond),
			emit_expr(then_expr),
			emit_expr(else_expr)
		),
		Expr::Coalesce { left, right, .. } => {
			format!(
				"{}.unwrap_or_else(|| {})",
				emit_expr(left),
				emit_expr(right)
			)
		}
	}
}

fn emit_string_expr(expr: &Expr) -> String {
	match expr {
		Expr::Path(_, _) => format!("&{}", emit_expr(expr)),
		_ => emit_expr(expr),
	}
}

fn is_string_prop(name: &str) -> bool {
	matches!(
		name,
		"textAlign"
			| "cursor"
			| "overflow"
			| "placeholder"
			| "backgroundColor"
			| "border"
			| "objectFit"
	)
}

fn should_emit_prop(tag: &str, prop: &IrProp) -> bool {
	match prop {
		IrProp::Event { .. } => true,
		IrProp::Literal { name, .. }
		| IrProp::Number { name, .. }
		| IrProp::Bool { name, .. }
		| IrProp::Value { name, .. }
		| IrProp::Bind { name, .. } => match tag {
			"Text" => name != "value",
			"Button" => name != "text",
			"Image" => name != "src" && name != "alt",
			_ => name != "arg",
		},
	}
}

fn state_type_path(state_type: &str) -> String {
	if state_type.contains("::")
		|| state_type.starts_with("crate::")
		|| state_type.starts_with("super::")
	{
		state_type.to_string()
	} else {
		format!("crate::{}", state_type)
	}
}

fn action_variant(name: &str) -> String {
	let mut out = String::new();
	let mut upper_next = true;
	for ch in name.chars() {
		if ch.is_ascii_alphanumeric() {
			if upper_next {
				out.push(ch.to_ascii_uppercase());
				upper_next = false;
			} else {
				out.push(ch);
			}
		} else {
			upper_next = true;
		}
	}
	if out.is_empty() {
		"Action".to_string()
	} else {
		out
	}
}

fn action_id(name: &str) -> u32 {
	let mut hash = 0x811c9dc5u32;
	for byte in name.as_bytes() {
		hash ^= *byte as u32;
		hash = hash.wrapping_mul(0x01000193);
	}
	if hash == 0 {
		1
	} else {
		hash
	}
}
</file>

<file path="wgui/src/wui/runtime.rs">
use crate::gui::{self, Item};
use crate::wui::ast::{BinaryOp, Expr, Literal, UnaryOp};
use crate::wui::compiler::ir::{ActionDef, ActionPayload, EventKind, IrNode, IrProp, IrWidget};
use crate::wui::diagnostic::Diagnostic;

use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct Template {
	doc: crate::wui::compiler::ir::IrDocument,
}

#[derive(Debug, Clone)]
pub enum RuntimeAction {
	Click { name: String, arg: Option<u32> },
	TextChanged { name: String, value: String },
	SliderChange { name: String, value: i32 },
	Select { name: String, value: String },
}

#[derive(Debug, Clone)]
pub enum WuiValue {
	String(String),
	Number(f64),
	Bool(bool),
	Null,
	List(Vec<WuiValue>),
	Object(HashMap<String, WuiValue>),
}

pub trait WuiValueProvider {
	fn wui_value(&self) -> WuiValue;
}

impl Template {
	pub fn parse(source: &str, module_name: &str) -> Result<Self, Vec<Diagnostic>> {
		let parsed = crate::wui::parser::Parser::new(source).parse();
		let mut diags = parsed.diagnostics;
		let validated = crate::wui::compiler::validate::validate(&parsed.nodes, &mut diags);
		let Some(validated) = validated else {
			return Err(diags);
		};
		let lowered = crate::wui::compiler::lower::lower(&validated, module_name, &mut diags);
		if !diags.is_empty() {
			return Err(diags);
		}
		Ok(Self { doc: lowered })
	}

	pub fn render<T: WuiValueProvider>(&self, state: &T) -> Item {
		let mut ctx = EvalContext::new(state.wui_value());
		let mut children = Vec::new();
		render_nodes(&self.doc.nodes, &mut children, &mut ctx);
		gui::vstack(children)
	}

	pub fn decode(&self, event: &crate::types::ClientEvent) -> Option<RuntimeAction> {
		for action in &self.doc.actions {
			if let Some(decoded) = decode_action(action, event) {
				return Some(decoded);
			}
		}
		None
	}
}

impl WuiValue {
	pub fn object(entries: Vec<(String, WuiValue)>) -> Self {
		let mut map = HashMap::new();
		for (k, v) in entries {
			map.insert(k, v);
		}
		WuiValue::Object(map)
	}
}

struct EvalContext {
	vars: HashMap<String, WuiValue>,
}

impl EvalContext {
	fn new(state: WuiValue) -> Self {
		let mut vars = HashMap::new();
		vars.insert("state".to_string(), state);
		Self { vars }
	}

	fn with_var(&self, name: &str, value: WuiValue) -> Self {
		let mut vars = self.vars.clone();
		vars.insert(name.to_string(), value);
		Self { vars }
	}
}

fn decode_action(action: &ActionDef, event: &crate::types::ClientEvent) -> Option<RuntimeAction> {
	match action.kind {
		EventKind::Click => match event {
			crate::types::ClientEvent::OnClick(ev) if ev.id == action.id => match action.payload {
				ActionPayload::None => Some(RuntimeAction::Click {
					name: action.name.clone(),
					arg: None,
				}),
				ActionPayload::U32 => ev.inx.map(|arg| RuntimeAction::Click {
					name: action.name.clone(),
					arg: Some(arg),
				}),
				_ => None,
			},
			_ => None,
		},
		EventKind::TextChanged => match event {
			crate::types::ClientEvent::OnTextChanged(ev) if ev.id == action.id => {
				Some(RuntimeAction::TextChanged {
					name: action.name.clone(),
					value: ev.value.clone(),
				})
			}
			_ => None,
		},
		EventKind::SliderChange => match event {
			crate::types::ClientEvent::OnSliderChange(ev) if ev.id == action.id => {
				Some(RuntimeAction::SliderChange {
					name: action.name.clone(),
					value: ev.value,
				})
			}
			_ => None,
		},
		EventKind::Select => match event {
			crate::types::ClientEvent::OnSelect(ev) if ev.id == action.id => {
				Some(RuntimeAction::Select {
					name: action.name.clone(),
					value: ev.value.clone(),
				})
			}
			_ => None,
		},
	}
}

fn render_nodes(nodes: &[IrNode], out: &mut Vec<Item>, ctx: &mut EvalContext) {
	for node in nodes {
		match node {
			IrNode::Widget(widget) => out.push(render_widget(widget, ctx)),
			IrNode::Text(text) => out.push(gui::text(text)),
			IrNode::For(node) => {
				let list_value = eval_expr(&node.each, ctx);
				let WuiValue::List(items) = list_value else {
					continue;
				};
				for (inx, item) in items.into_iter().enumerate() {
					let mut nested = ctx.with_var(&node.item, item);
					if let Some(index) = &node.index {
						nested = nested.with_var(index, WuiValue::Number(inx as f64));
					}
					render_nodes(&node.body, out, &mut nested);
				}
			}
			IrNode::If(node) => {
				let test = eval_expr(&node.test, ctx);
				if value_as_bool(&test) {
					render_nodes(&node.then_body, out, ctx);
				} else {
					render_nodes(&node.else_body, out, ctx);
				}
			}
			IrNode::Scope(node) => {
				render_nodes(&node.body, out, ctx);
			}
		}
	}
}

fn render_widget(widget: &IrWidget, ctx: &mut EvalContext) -> Item {
	let mut base = match widget.tag.as_str() {
		"VStack" => render_container(gui::vstack, &widget.children, ctx),
		"HStack" => render_container(gui::hstack, &widget.children, ctx),
		"Text" => gui::text(&text_value(widget, ctx)),
		"Button" => gui::button(&textual_value(widget, ctx, "text")),
		"TextInput" => gui::text_input(),
		"Checkbox" => gui::checkbox(),
		"Slider" => gui::slider(),
		"Image" => {
			let (src, alt) = image_values(widget, ctx);
			gui::img(&src, &alt)
		}
		_ => gui::text("unsupported"),
	};

	for prop in &widget.props {
		if !should_apply_prop(&widget.tag, prop) {
			continue;
		}
		base = apply_prop(base, prop, ctx);
	}

	base
}

fn render_container<F>(builder: F, children: &[IrNode], ctx: &mut EvalContext) -> Item
where
	F: Fn(Vec<Item>) -> Item,
{
	let mut items = Vec::new();
	render_nodes(children, &mut items, ctx);
	builder(items)
}

fn text_value(widget: &IrWidget, ctx: &mut EvalContext) -> String {
	for prop in &widget.props {
		match prop {
			IrProp::Literal { name, value } if name == "value" => return value.clone(),
			IrProp::Value { name, expr } if name == "value" => {
				return value_as_string(&eval_expr(expr, ctx));
			}
			_ => {}
		}
	}
	String::new()
}

fn textual_value(widget: &IrWidget, ctx: &mut EvalContext, prop_name: &str) -> String {
	for prop in &widget.props {
		match prop {
			IrProp::Literal { name, value } if name == prop_name => return value.clone(),
			IrProp::Value { name, expr } if name == prop_name => {
				return value_as_string(&eval_expr(expr, ctx));
			}
			_ => {}
		}
	}
	String::new()
}

fn image_values(widget: &IrWidget, ctx: &mut EvalContext) -> (String, String) {
	let mut src = String::new();
	let mut alt = String::new();
	for prop in &widget.props {
		match prop {
			IrProp::Literal { name, value } if name == "src" => src = value.clone(),
			IrProp::Value { name, expr } if name == "src" => {
				src = value_as_string(&eval_expr(expr, ctx));
			}
			IrProp::Literal { name, value } if name == "alt" => alt = value.clone(),
			IrProp::Value { name, expr } if name == "alt" => {
				alt = value_as_string(&eval_expr(expr, ctx));
			}
			_ => {}
		}
	}
	(src, alt)
}

fn should_apply_prop(tag: &str, prop: &IrProp) -> bool {
	match prop {
		IrProp::Event { .. } => true,
		IrProp::Literal { name, .. }
		| IrProp::Number { name, .. }
		| IrProp::Bool { name, .. }
		| IrProp::Value { name, .. }
		| IrProp::Bind { name, .. } => match tag {
			"Text" => name != "value",
			"Button" => name != "text",
			"Image" => name != "src" && name != "alt",
			_ => true,
		},
	}
}

fn apply_prop(item: Item, prop: &IrProp, ctx: &mut EvalContext) -> Item {
	match prop {
		IrProp::Event { action, arg, .. } => {
			let mut item = item.id(action_id(action));
			if let Some(expr) = arg {
				let value = eval_expr(expr, ctx);
				if let Some(inx) = value_as_u32(&value) {
					item = item.inx(inx);
				}
			}
			item
		}
		IrProp::Literal { name, value } => apply_string_prop(item, name, value),
		IrProp::Number { name, value } => apply_number_prop(item, name, *value),
		IrProp::Bool { name, value } => apply_bool_prop(item, name, *value),
		IrProp::Value { name, expr } => {
			let value = eval_expr(expr, ctx);
			apply_value_prop(item, name, value)
		}
		IrProp::Bind { name, expr } => {
			let value = eval_expr(expr, ctx);
			apply_value_prop(item, name, value)
		}
	}
}

fn apply_value_prop(item: Item, name: &str, value: WuiValue) -> Item {
	if is_string_prop(name) {
		return apply_string_prop(item, name, &value_as_string(&value));
	}
	match value {
		WuiValue::Number(n) => apply_number_prop(item, name, n),
		WuiValue::Bool(b) => apply_bool_prop(item, name, b),
		WuiValue::String(s) => apply_string_prop(item, name, &s),
		_ => item,
	}
}

fn apply_string_prop(item: Item, name: &str, value: &str) -> Item {
	match name {
		"svalue" | "bind:svalue" => item.svalue(value),
		"placeholder" => item.placeholder(value),
		"textAlign" => item.text_align(value),
		"cursor" => item.cursor(value),
		"overflow" => item.overflow(value),
		"backgroundColor" => item.background_color(value),
		"border" => item.border(value),
		"objectFit" => item.object_fit(value),
		_ => item,
	}
}

fn apply_number_prop(item: Item, name: &str, value: f64) -> Item {
	match name {
		"ivalue" | "bind:ivalue" => item.ivalue(value as i32),
		"min" => item.min(value as i32),
		"max" => item.max(value as i32),
		"step" => item.step(value as i32),
		"spacing" => item.spacing(value as u32),
		"padding" => item.padding(value as u16),
		"paddingLeft" => item.padding_left(value as u16),
		"paddingRight" => item.padding_right(value as u16),
		"paddingTop" => item.padding_top(value as u16),
		"paddingBottom" => item.padding_bottom(value as u16),
		"margin" => item.margin(value as u16),
		"marginLeft" => item.margin_left(value as u16),
		"marginRight" => item.margin_right(value as u16),
		"marginTop" => item.margin_top(value as u16),
		"marginBottom" => item.margin_bottom(value as u16),
		"width" => item.width(value as u32),
		"height" => item.height(value as u32),
		"minWidth" => item.min_width(value as u32),
		"maxWidth" => item.max_width(value as u32),
		"minHeight" => item.min_height(value as u32),
		"maxHeight" => item.max_height(value as u32),
		"grow" => item.grow(value as u32),
		_ => item,
	}
}

fn apply_bool_prop(item: Item, name: &str, value: bool) -> Item {
	match name {
		"checked" | "bind:checked" => item.checked(value),
		"wrap" => item.wrap(value),
		_ => item,
	}
}

fn is_string_prop(name: &str) -> bool {
	matches!(
		name,
		"svalue"
			| "bind:svalue"
			| "placeholder"
			| "textAlign"
			| "cursor"
			| "overflow"
			| "backgroundColor"
			| "border"
			| "objectFit"
	)
}

fn eval_expr(expr: &Expr, ctx: &EvalContext) -> WuiValue {
	match expr {
		Expr::Literal(lit, _) => match lit {
			Literal::String(s) => WuiValue::String(s.clone()),
			Literal::Number(n) => WuiValue::Number(*n),
			Literal::Bool(b) => WuiValue::Bool(*b),
			Literal::Null => WuiValue::Null,
		},
		Expr::Path(parts, _) => resolve_path(parts, ctx),
		Expr::Unary { op, expr, .. } => match op {
			UnaryOp::Not => WuiValue::Bool(!value_as_bool(&eval_expr(expr, ctx))),
			UnaryOp::Neg => WuiValue::Number(-value_as_number(&eval_expr(expr, ctx))),
		},
		Expr::Binary {
			left, op, right, ..
		} => {
			let left = eval_expr(left, ctx);
			let right = eval_expr(right, ctx);
			match op {
				BinaryOp::Add => WuiValue::Number(value_as_number(&left) + value_as_number(&right)),
				BinaryOp::Sub => WuiValue::Number(value_as_number(&left) - value_as_number(&right)),
				BinaryOp::Mul => WuiValue::Number(value_as_number(&left) * value_as_number(&right)),
				BinaryOp::Div => WuiValue::Number(value_as_number(&left) / value_as_number(&right)),
				BinaryOp::Mod => WuiValue::Number(value_as_number(&left) % value_as_number(&right)),
				BinaryOp::Eq => WuiValue::Bool(values_equal(&left, &right)),
				BinaryOp::Neq => WuiValue::Bool(!values_equal(&left, &right)),
				BinaryOp::Lt => WuiValue::Bool(value_as_number(&left) < value_as_number(&right)),
				BinaryOp::Lte => WuiValue::Bool(value_as_number(&left) <= value_as_number(&right)),
				BinaryOp::Gt => WuiValue::Bool(value_as_number(&left) > value_as_number(&right)),
				BinaryOp::Gte => WuiValue::Bool(value_as_number(&left) >= value_as_number(&right)),
				BinaryOp::And => WuiValue::Bool(value_as_bool(&left) && value_as_bool(&right)),
				BinaryOp::Or => WuiValue::Bool(value_as_bool(&left) || value_as_bool(&right)),
			}
		}
		Expr::Ternary {
			cond,
			then_expr,
			else_expr,
			..
		} => {
			if value_as_bool(&eval_expr(cond, ctx)) {
				eval_expr(then_expr, ctx)
			} else {
				eval_expr(else_expr, ctx)
			}
		}
		Expr::Coalesce { left, right, .. } => {
			let left_value = eval_expr(left, ctx);
			if matches!(left_value, WuiValue::Null) {
				eval_expr(right, ctx)
			} else {
				left_value
			}
		}
	}
}

fn resolve_path(parts: &[String], ctx: &EvalContext) -> WuiValue {
	let Some((first, rest)) = parts.split_first() else {
		return WuiValue::Null;
	};
	let Some(mut current) = ctx.vars.get(first).cloned() else {
		return WuiValue::Null;
	};
	for part in rest {
		current = match current {
			WuiValue::Object(mut map) => map.remove(part).unwrap_or(WuiValue::Null),
			_ => WuiValue::Null,
		};
	}
	current
}

fn value_as_bool(value: &WuiValue) -> bool {
	match value {
		WuiValue::Bool(b) => *b,
		_ => false,
	}
}

fn value_as_number(value: &WuiValue) -> f64 {
	match value {
		WuiValue::Number(n) => *n,
		_ => 0.0,
	}
}

fn value_as_u32(value: &WuiValue) -> Option<u32> {
	match value {
		WuiValue::Number(n) if *n >= 0.0 => Some(*n as u32),
		_ => None,
	}
}

fn value_as_string(value: &WuiValue) -> String {
	match value {
		WuiValue::String(s) => s.clone(),
		WuiValue::Number(n) => n.to_string(),
		WuiValue::Bool(b) => b.to_string(),
		_ => String::new(),
	}
}

fn values_equal(left: &WuiValue, right: &WuiValue) -> bool {
	match (left, right) {
		(WuiValue::String(a), WuiValue::String(b)) => a == b,
		(WuiValue::Number(a), WuiValue::Number(b)) => (a - b).abs() < f64::EPSILON,
		(WuiValue::Bool(a), WuiValue::Bool(b)) => a == b,
		(WuiValue::Null, WuiValue::Null) => true,
		_ => false,
	}
}

fn action_id(name: &str) -> u32 {
	let mut hash = 0x811c9dc5u32;
	for byte in name.as_bytes() {
		hash ^= *byte as u32;
		hash = hash.wrapping_mul(0x01000193);
	}
	if hash == 0 {
		1
	} else {
		hash
	}
}
</file>

<file path="wgui/src/edit_distance.rs">
use std::{cmp::min, fmt::Debug, vec};

use log::log_enabled;

#[derive(Debug, PartialEq)]
pub enum EditOperation<T> {
	InsertFirst(T),
	InsertAfter(usize, T),
	InsertBack(T),
	RemoveAt(usize),
	ReplaceAt(usize, T),
}

pub fn get_minimum_edits<T: PartialEq + Clone + Debug>(
	s: &Vec<T>,
	t: &Vec<T>,
) -> Vec<EditOperation<T>> {
	log::trace!("get minimum edits");
	log::trace!("{:?}", s);
	log::trace!("{:?}", t);

	let m = s.len();
	let n = t.len();
	let mut dp = vec![vec![0; n + 1]; m + 1];

	// Initialize the base cases
	for i in 0..=m {
		dp[i][0] = i;
	}
	for j in 0..=n {
		dp[0][j] = j;
	}

	// Fill in the DP table
	for i in 1..=m {
		for j in 1..=n {
			if s[i - 1] == t[j - 1] {
				dp[i][j] = dp[i - 1][j - 1];
			} else {
				dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;
			}
		}
	}

	if log_enabled!(log::Level::Trace) {
		log::trace!("DP table:");

		for i in 0..=m {
			let mut row = vec![];

			for j in 0..=n {
				row.push(dp[i][j]);
			}

			log::trace!("{:?}", row)
		}
	}

	// Initialize the list of edit operations
	let mut edits = Vec::new();

	let mut it = 1;

	log::trace!("backtracking edit operations");

	// Backtrack to generate the list of edit operations
	let mut i = m;
	let mut j = n;
	while i > 0 || j > 0 {
		log::trace!("");
		log::trace!("Iteration {}", it);
		it += 1;
		log::trace!("i = {}, j = {} val = {:?}", i, j, dp[i][j]);

		if i == 0 {
			// Insert t[j - 1]
			log::trace!("Insert first {:?}", t[j - 1]);
			edits.push(EditOperation::InsertFirst(t[j - 1].clone()));
			j -= 1;

			continue;
		} else if j == 0 {
			// Delete s[i - 1]
			log::trace!("Remove {:?} at {}", s[i - 1], i - 1);
			edits.push(EditOperation::RemoveAt(i - 1));
			i -= 1;

			continue;
		} else if s[i - 1] == t[j - 1] {
			// No operation required
			log::trace!("No operation required");
			i -= 1;
			j -= 1;

			continue;
		}

		let top = dp[i - 1][j];
		let left = dp[i][j - 1];
		let diag = dp[i - 1][j - 1];

		if diag < top && diag < left {
			log::trace!("Replace {:?} with {:?}", s[i - 1], t[j - 1]);
			edits.push(EditOperation::ReplaceAt(i - 1, t[j - 1].clone()));
			i -= 1;
			j -= 1;
		} else if top < left {
			log::trace!("Remove {:?} at {}", s[i - 1], i - 1);
			edits.push(EditOperation::RemoveAt(i - 1));
			i -= 1;
		} else {
			log::trace!("Insert at {:?}", t[j - 1]);
			edits.push(EditOperation::InsertAfter(i - 1, t[j - 1].clone()));
			j -= 1;
		}
	}

	log::trace!("edits {:?}", edits);

	// Reverse the list of edit operations to get the correct order
	// edits.reverse();

	edits
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_insert_front() {
		let a = vec![1, 2, 3];
		let b = vec![0, 1, 2, 3];

		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::InsertFirst(0)]);
	}

	#[test]
	fn test_insert_back() {
		let a = vec![1, 2, 3];
		let b = vec![1, 2, 3, 4];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::InsertAfter(2, 4)]);
	}

	#[test]
	fn test_insert_middle() {
		let a = vec![1, 2, 3];
		let b = vec![1, 2, 4, 3];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::InsertAfter(1, 4)]);
	}

	#[test]
	fn test_remove_first() {
		let a = vec![1, 2, 3];
		let b = vec![2, 3];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::RemoveAt(0)]);
	}

	#[test]
	fn test_remove_last() {
		let a = vec![1, 2, 3];
		let b = vec![1, 2];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::RemoveAt(2)]);
	}

	#[test]
	fn test_remove_middle() {
		let a = vec![1, 2, 3];
		let b = vec![1, 3];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::RemoveAt(1)]);
	}

	#[test]
	fn test_replace_first() {
		let a = vec![1, 2, 3];
		let b = vec![4, 2, 3];

		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::ReplaceAt(0, 4)]);
	}

	#[test]
	fn test_replace_last() {
		let a = vec![1, 2, 3];
		let b = vec![1, 2, 4];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::ReplaceAt(2, 4)]);
	}

	#[test]
	fn test_replace_middle() {
		let a = vec![1, 2, 3];
		let b = vec![1, 4, 3];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(edits, vec![EditOperation::ReplaceAt(1, 4)]);
	}

	#[test]
	fn test_replace_all() {
		let a = vec![1, 2, 3];
		let b = vec![4, 5, 6];
		let edits = get_minimum_edits(&a, &b);

		assert_eq!(
			edits,
			vec![
				EditOperation::ReplaceAt(2, 6),
				EditOperation::ReplaceAt(1, 5),
				EditOperation::ReplaceAt(0, 4)
			]
		);
	}

	#[test]
	fn test_move_from_back_to_front() {
		let a = vec![1, 2, 3];
		let b = vec![3, 1, 2];

		let edits = get_minimum_edits(&a, &b);

		assert_eq!(
			edits,
			vec![EditOperation::RemoveAt(2), EditOperation::InsertFirst(3)]
		);
	}

	#[test]
	fn test_string() {
		let old = "sitting";
		let new = "kitten";

		let edits = get_minimum_edits(
			&old.chars().collect::<Vec<_>>(),
			&new.chars().collect::<Vec<_>>(),
		);

		assert_eq!(
			edits,
			vec![
				EditOperation::RemoveAt(6),
				EditOperation::ReplaceAt(4, 'e'),
				EditOperation::ReplaceAt(0, 'k')
			]
		);
	}

	#[test]
	fn test_replace_one_with_two() {
		let old = "A";
		let new = "BC";

		let edits = get_minimum_edits(
			&old.chars().collect::<Vec<_>>(),
			&new.chars().collect::<Vec<_>>(),
		);

		assert_eq!(
			edits,
			vec![
				EditOperation::ReplaceAt(0, 'C'),
				EditOperation::InsertFirst('B'),
			]
		);
	}
}
</file>

<file path="wgui/src/ws.rs">
#[cfg(feature = "hyper")]
use std::pin::Pin;
use std::sync::atomic::{AtomicU64, Ordering};
#[cfg(feature = "hyper")]
use std::task::{Context, Poll};

use anyhow::Error;
use futures_util::{Sink, Stream};
#[cfg(feature = "hyper")]
use hyper_tungstenite::tungstenite::Message as TungsteniteMessage;
#[cfg(feature = "hyper")]
use hyper_util::rt::TokioIo;

static CLIENT_ID: AtomicU64 = AtomicU64::new(1);

pub fn next_client_id() -> usize {
	CLIENT_ID.fetch_add(1, Ordering::Relaxed) as usize
}

#[derive(Debug)]
pub enum WsMessage {
	Text(String),
	Binary(Vec<u8>),
	Ping(Vec<u8>),
	Pong(Vec<u8>),
	Close,
}

pub trait WsStream:
	Stream<Item = Result<WsMessage, Error>> + Sink<WsMessage, Error = Error> + Unpin + Send
{
}

impl<T> WsStream for T where
	T: Stream<Item = Result<WsMessage, Error>> + Sink<WsMessage, Error = Error> + Unpin + Send
{
}

#[cfg(feature = "hyper")]
pub struct TungsteniteWs<S> {
	inner: S,
}

#[cfg(feature = "hyper")]
impl<S> TungsteniteWs<S> {
	pub fn new(inner: S) -> Self {
		Self { inner }
	}
}

#[cfg(feature = "hyper")]
impl Stream
	for TungsteniteWs<hyper_tungstenite::WebSocketStream<TokioIo<hyper::upgrade::Upgraded>>>
{
	type Item = Result<WsMessage, Error>;

	fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
		match Pin::new(&mut self.inner).poll_next(cx) {
			Poll::Ready(Some(Ok(msg))) => Poll::Ready(Some(Ok(msg.into()))),
			Poll::Ready(Some(Err(err))) => Poll::Ready(Some(Err(err.into()))),
			Poll::Ready(None) => Poll::Ready(None),
			Poll::Pending => Poll::Pending,
		}
	}
}

#[cfg(feature = "hyper")]
impl Sink<WsMessage>
	for TungsteniteWs<hyper_tungstenite::WebSocketStream<TokioIo<hyper::upgrade::Upgraded>>>
{
	type Error = Error;

	fn poll_ready(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Pin::new(&mut self.inner)
			.poll_ready(cx)
			.map_err(Error::from)
	}

	fn start_send(mut self: Pin<&mut Self>, item: WsMessage) -> Result<(), Self::Error> {
		Pin::new(&mut self.inner)
			.start_send(item.try_into()?)
			.map_err(Error::from)
	}

	fn poll_flush(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Pin::new(&mut self.inner)
			.poll_flush(cx)
			.map_err(Error::from)
	}

	fn poll_close(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Pin::new(&mut self.inner)
			.poll_close(cx)
			.map_err(Error::from)
	}
}

#[cfg(feature = "hyper")]
impl From<TungsteniteMessage> for WsMessage {
	fn from(value: TungsteniteMessage) -> Self {
		match value {
			TungsteniteMessage::Text(msg) => WsMessage::Text(msg),
			TungsteniteMessage::Binary(msg) => WsMessage::Binary(msg),
			TungsteniteMessage::Ping(msg) => WsMessage::Ping(msg),
			TungsteniteMessage::Pong(msg) => WsMessage::Pong(msg),
			TungsteniteMessage::Close(_) => WsMessage::Close,
			TungsteniteMessage::Frame(_) => WsMessage::Close,
		}
	}
}

#[cfg(feature = "hyper")]
impl TryFrom<WsMessage> for TungsteniteMessage {
	type Error = Error;

	fn try_from(value: WsMessage) -> Result<Self, Self::Error> {
		let msg = match value {
			WsMessage::Text(msg) => TungsteniteMessage::Text(msg),
			WsMessage::Binary(msg) => TungsteniteMessage::Binary(msg),
			WsMessage::Ping(msg) => TungsteniteMessage::Ping(msg),
			WsMessage::Pong(msg) => TungsteniteMessage::Pong(msg),
			WsMessage::Close => TungsteniteMessage::Close(None),
		};

		Ok(msg)
	}
}
</file>

<file path=".gitignore">
/target
.DS_Store
</file>

<file path="Cargo.toml">
[workspace]
members = [
    "wgui",
    "wui-lsp",
    "examples/*"
]

[workspace.dependencies]
axum = "0.8"
</file>

<file path="examples/todo/Cargo.toml">
[package]
name = "todo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wgui = { path = "../../wgui", features = ["hyper"] }
tokio = { version = "1", features = ["full"] }
simple_logger = "4"
log = "0.4"
</file>

<file path="examples/todo_wui/src/main.rs">
use log::Level;
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::{Duration, SystemTime};
use tokio::sync::mpsc;
use wgui::wui::runtime::{RuntimeAction, Template, WuiValue, WuiValueProvider};
use wgui::*;

#[derive(Debug, Clone)]
struct TodoItem {
	id: u32,
	name: String,
	completed: bool,
}

impl TodoItem {
	fn to_wui_value(&self) -> WuiValue {
		WuiValue::object(vec![
			("id".to_string(), WuiValue::Number(self.id as f64)),
			("name".to_string(), WuiValue::String(self.name.clone())),
			("completed".to_string(), WuiValue::Bool(self.completed)),
		])
	}
}

#[derive(Debug, Default, Clone)]
struct TodoState {
	new_todo_name: String,
	items: Vec<TodoItem>,
}

impl WuiValueProvider for TodoState {
	fn wui_value(&self) -> WuiValue {
		WuiValue::object(vec![
			(
				"new_todo_name".to_string(),
				WuiValue::String(self.new_todo_name.clone()),
			),
			(
				"items".to_string(),
				WuiValue::List(self.items.iter().map(|item| item.to_wui_value()).collect()),
			),
		])
	}
}

fn load_template(path: &Path, module_name: &str) -> Template {
	let source = fs::read_to_string(path).unwrap_or_else(|err| {
		panic!("failed to read {}: {}", path.display(), err);
	});
	match Template::parse(&source, module_name) {
		Ok(template) => template,
		Err(diags) => {
			for diag in diags {
				eprintln!(
					"template error: {} at {}..{}",
					diag.message, diag.span.start, diag.span.end
				);
			}
			panic!("failed to parse template");
		}
	}
}

fn file_mtime(path: &Path) -> SystemTime {
	fs::metadata(path)
		.and_then(|meta| meta.modified())
		.unwrap_or(SystemTime::UNIX_EPOCH)
}

fn watch_template(path: PathBuf, tx: mpsc::UnboundedSender<()>) {
	let mut last_mtime = file_mtime(&path);
	loop {
		thread::sleep(Duration::from_millis(250));
		let mtime = file_mtime(&path);
		if mtime > last_mtime {
			last_mtime = mtime;
			let _ = tx.send(());
		}
	}
}

#[tokio::main]
async fn main() {
	simple_logger::init_with_level(Level::Info).unwrap();

	let state = Arc::new(RwLock::new(TodoState::default()));
	let mut client_ids = HashSet::new();
	let mut next_id: u32 = 1;

	let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap_or_else(|_| ".".to_string());
	let template_path = Path::new(&manifest_dir).join("wui/pages/todo.wui");
	let template = Arc::new(RwLock::new(load_template(&template_path, "todo")));
	let (reload_tx, mut reload_rx) = mpsc::unbounded_channel();
	thread::spawn({
		let path = template_path.clone();
		move || watch_template(path, reload_tx)
	});

	let ssr_state = state.clone();
	let ssr_template = template.clone();
	let mut wgui = Wgui::new_with_ssr(
		"0.0.0.0:12345".parse().unwrap(),
		Arc::new(move || {
			let state = ssr_state.read().unwrap();
			let template = ssr_template.read().unwrap();
			template.render(&*state)
		}),
	);

	loop {
		tokio::select! {
			event = wgui.next() => {
				let Some(event) = event else { break; };
				match event {
					ClientEvent::Disconnected { id } => {
						client_ids.remove(&id);
					}
					ClientEvent::Connected { id } => {
						let template = template.read().unwrap();
						let state = state.read().unwrap();
						wgui.render(id, template.render(&*state)).await;
						client_ids.insert(id);
					}
					ClientEvent::PathChanged(_) => {}
					ClientEvent::Input(_) => {}
					_ => {
						let action = {
							let template = template.read().unwrap();
							template.decode(&event)
						};
						if let Some(action) = action {
							let mut state = state.write().unwrap();
							match action {
								RuntimeAction::Click { name, arg } => match name.as_str() {
									"AddTodo" => {
										let name = state.new_todo_name.trim().to_string();
										if !name.is_empty() {
											state.items.push(TodoItem {
												id: next_id,
												name,
												completed: false,
											});
											next_id += 1;
										}
										state.new_todo_name.clear();
									}
									"ToggleTodo" => {
										if let Some(arg) = arg {
											if let Some(item) = state.items.iter_mut().find(|item| item.id == arg) {
												item.completed = !item.completed;
											}
										}
									}
									_ => {}
								},
								RuntimeAction::TextChanged { name, value } => {
									if name == "EditNewTodo" {
										state.new_todo_name = value;
									}
								}
								_ => {}
							}
						}
					}
				}
			}
			Some(()) = reload_rx.recv() => {
				let source = match fs::read_to_string(&template_path) {
					Ok(source) => source,
					Err(err) => {
						log::warn!("failed to read {}: {}", template_path.display(), err);
						continue;
					}
				};
				match Template::parse(&source, "todo") {
					Ok(new_template) => {
						log::info!("reloaded template {}", template_path.display());
						*template.write().unwrap() = new_template;
						for id in &client_ids {
							let template = template.read().unwrap();
							let state = state.read().unwrap();
							wgui.render(*id, template.render(&*state)).await;
						}
					}
					Err(diags) => {
						for diag in diags {
							log::warn!("template error: {} at {}..{}", diag.message, diag.span.start, diag.span.end);
						}
					}
				}
			}
		}

		let (done, undone) = {
			let state = state.read().unwrap();
			let done = state.items.iter().filter(|item| item.completed).count();
			let undone = state.items.len() - done;
			(done, undone)
		};
		let title = format!("Todo {} done / {} undone", done, undone);

		for id in &client_ids {
			wgui.set_title(*id, &title).await;
			let template = template.read().unwrap();
			let state = state.read().unwrap();
			wgui.render(*id, template.render(&*state)).await;
		}
	}
}
</file>

<file path="ts/debouncer.ts">
export class Deboncer {
    private timeout: any
    private value = ""
    public valueChanged = false
    private cb: ((text: string) => void) | null = null

    public change(text: string) {
        this.valueChanged = true
        this.value = text
        clearTimeout(this.timeout)

        this.timeout = setTimeout(() => {
            this.trigger()
        }, 500)
    }

    public unregister() {
        this.cb = null
    }

    public register(cb: (v: string) => void) {
        this.cb = cb
    }

    public trigger() {
        if (this.timeout) {
            clearTimeout(this.timeout)
            this.timeout = null
        }

        if (!this.valueChanged) {
            return
        }

        this.valueChanged = false
        
        if (this.cb) {
            this.cb(this.value)  
        }

        this.value = ""
    }
}
</file>

<file path="ts/path.ts">
export const getPathItem = (path: number[], element: any): Element | undefined => {
    const p = path[0]
    if (p == null) {
        return element
    }
    const child = element.children[p]
    if (!child) {
        return
    }
    return getPathItem(path.slice(1), child)
}
</file>

<file path="wgui/src/axum.rs">
#![cfg(feature = "axum")]

use anyhow::Error;
use axum::{
	extract::ws::{Message as AxumMessage, WebSocket, WebSocketUpgrade},
	http::header,
	response::IntoResponse,
	routing::get,
	Router,
};
use futures_util::{Sink, Stream};
use std::pin::Pin;
use std::task::{Context, Poll};

use crate::{gui::Item, ssr, WguiHandle, WsMessage};
use std::sync::Arc;

/// Convenience router that exposes WgUi-specific routes for axum applications.
pub fn router(handle: WguiHandle) -> Router {
	let ws_handle = handle.clone();

	Router::new()
		.route(
			"/ws",
			get(move |ws: WebSocketUpgrade| {
				let handle = ws_handle.clone();
				async move {
					ws.on_upgrade(move |socket| async move {
						let ws = AxumWs::new(socket);
						handle.handle_ws(ws).await;
					})
				}
			}),
		)
		.route("/", get(index_html))
		.route("/index.js", get(index_js))
		.route("/index.css", get(index_css))
}

/// Convenience router that serves a server-rendered HTML snapshot on first load.
pub fn router_with_ssr(
	handle: WguiHandle,
	renderer: Arc<dyn Fn() -> Item + Send + Sync>,
) -> Router {
	let ws_handle = handle.clone();
	let ssr_renderer = renderer.clone();

	Router::new()
		.route(
			"/ws",
			get(move |ws: WebSocketUpgrade| {
				let handle = ws_handle.clone();
				async move {
					ws.on_upgrade(move |socket| async move {
						let ws = AxumWs::new(socket);
						handle.handle_ws(ws).await;
					})
				}
			}),
		)
		.route(
			"/",
			get(move || {
				let renderer = ssr_renderer.clone();
				async move { index_html_ssr(renderer).await }
			}),
		)
		.route("/index.js", get(index_js))
		.route("/index.css", get(index_css))
}

async fn index_html() -> impl IntoResponse {
	(
		[(header::CONTENT_TYPE, "text/html")],
		crate::dist::index_html(),
	)
}

async fn index_html_ssr(renderer: Arc<dyn Fn() -> Item + Send + Sync>) -> impl IntoResponse {
	let item = (renderer)();
	let html = ssr::render_document(&item);
	([(header::CONTENT_TYPE, "text/html")], html)
}

async fn index_js() -> impl IntoResponse {
	(
		[(header::CONTENT_TYPE, "text/javascript")],
		crate::dist::index_js(),
	)
}

async fn index_css() -> impl IntoResponse {
	(
		[(header::CONTENT_TYPE, "text/css")],
		crate::dist::index_css(),
	)
}

struct AxumWs {
	inner: WebSocket,
}

impl AxumWs {
	fn new(inner: WebSocket) -> Self {
		Self { inner }
	}
}

impl Stream for AxumWs {
	type Item = Result<WsMessage, Error>;

	fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
		match Stream::poll_next(Pin::new(&mut self.inner), cx) {
			Poll::Ready(Some(Ok(msg))) => {
				let converted = match msg {
					AxumMessage::Text(text) => WsMessage::Text(text.to_string()),
					AxumMessage::Binary(data) => WsMessage::Binary(data.to_vec()),
					AxumMessage::Ping(data) => WsMessage::Ping(data.to_vec()),
					AxumMessage::Pong(data) => WsMessage::Pong(data.to_vec()),
					AxumMessage::Close(_) => WsMessage::Close,
				};
				Poll::Ready(Some(Ok(converted)))
			}
			Poll::Ready(Some(Err(err))) => Poll::Ready(Some(Err(err.into()))),
			Poll::Ready(None) => Poll::Ready(None),
			Poll::Pending => Poll::Pending,
		}
	}
}

impl Sink<WsMessage> for AxumWs {
	type Error = Error;

	fn poll_ready(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Sink::poll_ready(Pin::new(&mut self.inner), cx).map_err(Into::into)
	}

	fn start_send(mut self: Pin<&mut Self>, item: WsMessage) -> Result<(), Self::Error> {
		let msg = match item {
			WsMessage::Text(text) => AxumMessage::Text(text.into()),
			WsMessage::Binary(data) => AxumMessage::Binary(data.into()),
			WsMessage::Ping(data) => AxumMessage::Ping(data.into()),
			WsMessage::Pong(data) => AxumMessage::Pong(data.into()),
			WsMessage::Close => AxumMessage::Close(None),
		};

		Sink::start_send(Pin::new(&mut self.inner), msg).map_err(Into::into)
	}

	fn poll_flush(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Sink::poll_flush(Pin::new(&mut self.inner), cx).map_err(Into::into)
	}

	fn poll_close(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Sink::poll_close(Pin::new(&mut self.inner), cx).map_err(Into::into)
	}
}
</file>

<file path="wgui/Cargo.toml">
[package]
name = "wgui"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[features]
default = ["hyper"]
hyper = ["dep:hyper", "dep:http-body-util", "dep:hyper-util", "dep:hyper-tungstenite"]
axum = ["dep:axum"]

[dependencies]
log = "0.4"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
anyhow = "1"
futures-util = { version = "0.3", features = ["sink"] }
tokio = { version = "1", features = ["full"] }
hyper = { version = "1", features = ["full"], optional = true }
http-body-util = { version = "0.1", optional = true }
hyper-util = { version = "0.1", features = ["full"], optional = true }
hyper-tungstenite = { version = "0.13.0", optional = true }
axum = { workspace = true, optional = true, features = ["ws"] }
</file>

<file path="ts/message_sender.ts">
import { MessageToSrv } from "./types.ts";

type SendMsgs = (msg: MessageToSrv[]) => void

export class MessageSender {
    private sender: SendMsgs
    private queue: MessageToSrv[] = []
    private timeout = 0
    constructor(send: SendMsgs) {
        this.sender = send
    }

    public send(msg: MessageToSrv) {
		this.queue = this.queue.filter((m) => {
			if (m.type === msg.type) {
				return false
			}
			return true
		})
        this.queue.push(msg)
        this.sendNext()
    }

    private sendNext() {
        if (this.timeout) {
            clearTimeout(this.timeout)
        }
        this.timeout = setTimeout(() => {
            this.sendNow()
        }, 500)
    }

    public sendNow() {
        clearInterval(this.timeout)
        this.timeout = 0
        if (this.queue.length === 0) {
            return
        }     
        this.sender(this.queue)
        this.queue = []
    }
}
</file>

<file path="ts/ws.ts">
import { MessageSender } from "./message_sender.ts";
import { MessageToSrv, SrvMessage } from "./types.ts";

type OnMessage = (sender: MessageSender, msgs: SrvMessage[]) => void
type OnOpen = (sender: MessageSender) => void

export const connectWebsocket = (args: {
    onMessage: OnMessage
    onOpen: OnOpen
}) => {
    let ws: WebSocket | undefined

    const sender = new MessageSender((msgs: MessageToSrv[]) => {
        if (!ws) {
            return
        }

        ws.send(JSON.stringify(msgs))
    })

    const createConnection = () => {
        const href = window.location.href
        const url = new URL(href)
        const wsProtocol = url.protocol === "https:" ? "wss" : "ws"
        const wsUrl = `${wsProtocol}://${url.host}/ws`
        ws = new WebSocket(wsUrl)

        ws.onmessage = (e) => {
            const data = e.data.toString()
            const messages = JSON.parse(data) as SrvMessage[]
            args.onMessage(sender, messages)
        }
    
        ws.onopen = () => {
            args.onOpen(sender)
        }
    
        ws.onclose = () => {
            setTimeout(() => {
                createConnection()
            }, 1000)
        }

        ws.onerror = (e) => {
            console.error("error", e)
        }
    }

    createConnection()

    return {
        close: () => {
            if (!ws) {
                return
            }

            ws.close()
        },
        sender
    }
}
</file>

<file path="wgui/src/diff.rs">
use crate::edit_distance::get_minimum_edits;
use crate::edit_distance::EditOperation;
use crate::gui::Item;
use crate::gui::ItemPayload;
use crate::types::AddFront;
use crate::types::ClientAction;
use crate::types::InsertAt;
use crate::types::ItemPath;
use crate::types::PropKey;
use crate::types::RemoveInx;
use crate::types::Replace;
use crate::types::SetProp;
use crate::types::Value;

fn inner_diff(changes: &mut Vec<ClientAction>, old: &Item, new: &Item, path: ItemPath) {
	log::trace!("{:?} inner_dif", path);
	let mut sets: Vec<SetProp> = Vec::new();

	match (&old.payload, &new.payload) {
		(ItemPayload::Layout(old), ItemPayload::Layout(new)) => {
			log::trace!("{:?} layout", path);

			if old.spacing != new.spacing {
				println!("{:?} spacing is different", path);
				sets.push(SetProp {
					key: PropKey::Spacing,
					value: Value::Number(new.spacing),
				})
			}

			let edits = get_minimum_edits(&old.body, &new.body);
			for edit in edits {
				match edit {
					EditOperation::InsertFirst(item) => {
						log::trace!("{:?} insert first", path);

						changes.push(ClientAction::AddFront(AddFront {
							path: path.clone(),
							item: item,
						}));
					}
					EditOperation::InsertAfter(index, item) => {
						log::trace!("{:?} insert after {}", path, index);

						changes.push(ClientAction::InsertAt(InsertAt {
							path: path.clone(),
							inx: index,
							item: item,
						}));
					}
					EditOperation::RemoveAt(index) => {
						log::trace!("{:?} remove at index {}", path, index);

						changes.push(ClientAction::RemoveInx(RemoveInx {
							path: path.clone(),
							inx: index,
						}));
					}
					EditOperation::ReplaceAt(i, item) => {
						log::trace!("{:?} replace at {}", path, i);

						let mut path = path.clone();
						path.push(i);

						log::trace!("{:?} new path: {:?}", path, path);

						inner_diff(changes, &old.body[i], &item, path);
					}
					EditOperation::InsertBack(item) => {
						log::trace!("{:?} insert back", path);

						todo!();
					}
				}
			}
		}
		_ => {
			if old != new {
				log::trace!("{:?} old and new are different", path);

				changes.push(ClientAction::Replace(Replace {
					path: path.clone(),
					item: new.clone(),
				}));
			}
		}
	}

	if old.id != new.id {
		sets.push(SetProp {
			key: PropKey::ID,
			value: Value::Number(new.id),
		})
	}

	if old.border != new.border {
		println!("{:?} border is different", path);
		sets.push(SetProp {
			key: PropKey::Border,
			value: Value::String(new.border.clone()),
		});
	}
	if old.background_color != new.background_color {
		// changes.push(ClientAction::SetStyle {
		// 	path: path.clone(),
		// 	prop: "background-color".to_string(),
		// 	value: new.background_color.to_string()
		// })
		sets.push(SetProp {
			key: PropKey::BackgroundColor,
			value: Value::String(new.background_color.clone()),
		});
	}

	if sets.len() > 0 {
		changes.push(ClientAction::SetProp {
			path: path.clone(),
			sets,
		});
	}

	// match (old, new) {
	//     (Item::View(old), Item::View(new)) => {
	//         log::trace!("{:?} inner_diff calculating view minumum edits", path);

	// 		// if old != new {
	// 		// 	println!("{:?} old and new are different", path);
	// 		// 	if old.background_color != new.background_color {
	// 		// 		println!("{:?} background color is different", path);
	// 		// 	}

	// 		// }

	// 		if old.spacing != new.spacing {
	// 			changes.push(ClientAction::SetStyle {
	// 				path: path.clone(),
	// 				prop: "gap".to_string(),
	// 				value: new.spacing.unwrap_or_default().to_string()
	// 			})
	// 		}
	//     }
	//     _ => {
	//         log::trace!("{:?} comparing old and new", path);

	//         if old != new {
	//             log::trace!("{:?} old and new are different", path);

	//             changes.push(
	//                 ClientAction::Replace(
	//                     Replace {
	//                         path: path.clone(),
	//                         item: new.clone()
	//                     }
	//                 )
	//             );
	//         }
	//     }
	// }
}

pub fn diff(old: &Item, new: &Item) -> Vec<ClientAction> {
	log::trace!("diff");
	log::trace!("{:?}", old);
	log::trace!("{:?}", new);
	let mut changes = Vec::new();
	let mut path = Vec::new();
	inner_diff(&mut changes, old, new, path);
	log::debug!("diff changes: {:?}", changes);
	changes
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::gui::hstack;

	#[test]
	fn test_view_metadata_diff() {
		let old = hstack([]);
		let new = hstack([]).spacing(10);

		let changes = super::diff(&old.into(), &new.into());
		println!("{:?}", changes);
	}
}
</file>

<file path="readme.md">
# wgui

Ever wondered that you would like to make web gui with rust and server-side virtual dom... probably not but here it is.

## Quick start

```rust
use log::Level;
use std::collections::HashSet;
use wgui::*;

fn render() -> Item {
	vstack([text("Hello wgui")]).into()
}

#[tokio::main]
async fn main() {
	simple_logger::init_with_level(Level::Info).unwrap();
	let mut wgui = Wgui::new("0.0.0.0:12345".parse().unwrap());
	let mut client_ids = HashSet::new();

	while let Some(event) = wgui.next().await {
		match event {
			ClientEvent::Disconnected { id } => {
				client_ids.remove(&id);
			}
			ClientEvent::Connected { id } => {
				wgui.render(id, render()).await;
				client_ids.insert(id);
			}
			_ => {}
		}

		for id in &client_ids {
			wgui.render(*id, render()).await;
		}
	}
}
```

## Examples

- Todo list app (interactive text input + checkbox): `cargo run -p todo`
- Component showcase (text input, select, slider, modal, table): `cargo run -p allcomponents`
- WUI template example with hot reload: `cargo run -p todo_wui`

## WUI templates

See `docs/wui.md` for the WUI template language, compiler/runtime usage, and hot reload notes.

## LSP

See `docs/lsp.md` for setting up the `wui-lsp` server in Zed or other editors.

## API overview

- Core runtime: `Wgui::new(addr)`, `wgui.next().await`, `wgui.render(client_id, item)`
- SSR snapshot: `Wgui::new_with_ssr(addr, || render())` or `axum::router_with_ssr(...)`
- Events: `ClientEvent::{Connected, Disconnected, OnClick, OnTextChanged, OnSliderChange, OnSelect, PathChanged}`

Component builders

- Layout: `vstack`, `hstack`
- Text: `text`
- Inputs: `text_input`, `textarea`, `select` + `option`, `checkbox`, `slider`
- Actions: `button`
- Table: `table`, `thead`, `tbody`, `tr`, `th`, `td`
- Media: `img`
- Overlays: `modal`
- Misc: `folder_picker`

Item modifiers

- Identity: `.id(u32)`, `.inx(u32)`
- Value helpers: `.svalue(&str)`, `.ivalue(i32)`, `.checked(bool)`, `.placeholder(&str)`, `.min(i32)`, `.max(i32)`, `.step(i32)`, `.open(bool)`
- Layout/style: `.spacing(u32)`, `.wrap(bool)`, `.grow(u32)`, `.width(u32)`, `.min_width(u32)`, `.max_width(u32)`, `.height(u32)`, `.min_height(u32)`, `.max_height(u32)`
- Box model: `.margin(u16)`, `.margin_left(u16)`, `.margin_right(u16)`, `.margin_top(u16)`, `.margin_bottom(u16)`, `.padding(u16)`, `.padding_left(u16)`, `.padding_right(u16)`, `.padding_top(u16)`, `.padding_bottom(u16)`
- Visuals: `.border(&str)`, `.background_color(&str)`, `.text_align(&str)`, `.cursor(&str)`, `.overflow(&str)`, `.editable(bool)`, `.hresize(bool)`, `.vresize(bool)`

## Development

```
# Build
bun build ./ts/app.ts --watch --outfile ./dist/index.js
# Check 
bunx tsc ./ts/* --noEmit --allowImportingTsExtensions
```
</file>

<file path="wgui/src/ui_client.rs">
use super::{gui::Item, types::ClientEvent};
use crate::{
	diff::diff,
	types::{ClientAction, Clients, Command, Replace},
	ws::{WsMessage, WsStream},
};
use futures_util::{SinkExt, StreamExt};
use tokio::sync::mpsc;

pub struct UiWsWorker<S>
where
	S: WsStream,
{
	id: usize,
	ws: S,
	event_tx: mpsc::UnboundedSender<ClientEvent>,
	cmd_recv: mpsc::UnboundedReceiver<Command>,
	clients: Clients,
	last_root: Option<Item>,
}

impl<S> UiWsWorker<S>
where
	S: WsStream,
{
	pub async fn new(
		id: usize,
		ws: S,
		event_tx: mpsc::UnboundedSender<ClientEvent>,
		clients: Clients,
	) -> Self {
		log::info!("[{}] connection started", id);
		let (cmd_sender, cmd_recv) = mpsc::unbounded_channel();
		clients.write().await.insert(id, cmd_sender);
		event_tx.send(ClientEvent::Connected { id }).unwrap();
		Self {
			id,
			ws,
			cmd_recv: cmd_recv,
			event_tx,
			last_root: None,
			clients,
		}
	}

	pub async fn handle_websocket(&mut self, msg: WsMessage) -> anyhow::Result<()> {
		match msg {
			WsMessage::Text(msg) => {
				log::info!("recieved message: {}", msg);

				let msgs: Vec<ClientEvent> = serde_json::from_str(&msg)?;

				log::info!("received messages: {:?}", msgs);

				for msg in msgs {
					self.event_tx.send(msg).unwrap();
				}
			}
			WsMessage::Binary(msg) => {
				println!("Received binary message: {:02X?}", msg);
				self.ws
					.send(WsMessage::Binary(b"Thank you, come again.".to_vec()))
					.await?;
			}
			WsMessage::Ping(msg) => {
				log::info!("Received ping message: {:02X?}", msg);
			}
			WsMessage::Pong(msg) => {
				log::info!("Received pong message: {:02X?}", msg);
			}
			WsMessage::Close => {
				println!("Received close message");
			}
		};

		Ok(())
	}

	async fn handle_command(&mut self, cmd: Command) -> anyhow::Result<()> {
		log::debug!("handling command: {:?}", cmd);
		match cmd {
			Command::Render(root) => {
				let changes = match &self.last_root {
					Some(last_root) => {
						let changes = diff(&last_root, &root);
						changes
					}
					None => vec![ClientAction::Replace(Replace {
						path: vec![],
						item: root.clone(),
					})],
				};
				if changes.len() == 0 {
					return Ok(());
				}
				self.last_root = Some(root);
				log::debug!("sending changes: {:?}", changes);
				let str = serde_json::to_string(&changes).unwrap();
				self.ws.send(WsMessage::Text(str)).await?;
			}
			Command::SetTitle(title) => {
				let changes = vec![ClientAction::SetTitle { title }];
				let str = serde_json::to_string(&changes).unwrap();
				self.ws.send(WsMessage::Text(str)).await?;
			}
		};

		Ok(())
	}

	pub async fn run(mut self) {
		loop {
			tokio::select! {
				msg = self.ws.next() => {
					match msg {
						Some(msg) => match msg {
							Ok(msg) => {
								match self.handle_websocket(msg).await {
									Ok(_) => {},
									Err(err) => {
										log::error!("Error handling websocket message: {}", err);
									},
								}
							},
							Err(err) => {
								log::error!("Error receiving websocket message: {}", err);

								break;
							},
						},
						None => {
							log::error!("Websocket closed");

							break;
						},
					}
				}
				cmd = self.cmd_recv.recv() => {
					match cmd {
						Some(cmd) => {
							match self.handle_command(cmd).await {
								Ok(_) => {},
								Err(err) => {
									log::error!("Error handling command: {}", err);
								}
							}
						}
						None => {
							log::error!("Command channel closed");

							break;
						}
					}
				}
			};
		}

		log::info!("[{}] connection closed", self.id);
		self.clients.write().await.remove(&self.id);
		self.event_tx
			.send(ClientEvent::Disconnected { id: self.id })
			.unwrap();
	}
}
</file>

<file path="ts/app.ts">
import { Deboncer } from "./debouncer.ts";
import { getPathItem } from "./path.ts";
import { renderItem } from "./render.ts";
import { Context, PropValue, SetPropSet, SrvMessage } from "./types.ts";
import { connectWebsocket } from "./ws.ts";

const getSetPropValue = (value?: PropValue) => {
    if (!value) {
        return undefined
    }
    if (value.String != null) {
        return value.String
    }
    if (value.Number != null) {
        return value.Number.toString()
    }
    return undefined
}

const applySetProp = (element: Element, set: SetPropSet) => {
    const value = getSetPropValue(set.value)
    if (value == null) {
        return
    }

    if (!(element instanceof HTMLElement)) {
        return
    }

    switch (set.key) {
        case "BackgroundColor":
            element.style.backgroundColor = value
            break
        case "Border":
            element.style.border = value
            break
        case "Spacing": {
            const parsed = Number(value)
            element.style.gap = isNaN(parsed) ? value : `${parsed}px`
            break
        }
        case "ID":
            element.id = value
            break
    }
}

window.onload = () => {
    const res = document.querySelector("body")

    if (!res) {
        return
    }

    res.style.display = "flex"
    res.style.flexDirection = "row"

    let root = res.querySelector("#wgui-root") as HTMLDivElement | null

    if (!root) {
        res.innerHTML = ""
        root = document.createElement("div")
        root.id = "wgui-root"
        res.appendChild(root)
    }
    const debouncer = new Deboncer()

    const {
        sender
    } = connectWebsocket({
        onMessage:  (sender, msgs: SrvMessage[]) => { 
            const ctx: Context = {
                sender,
                debouncer
            }
            
            for (const message of msgs) {
                if (message.type === "pushState") {
                    history.pushState({}, "", message.url)

                    sender.send({
                        type: "pathChanged",
                        path: location.pathname,
                        query: {}
                    })
                    sender.sendNow()

                    continue
                }

                if (message.type === "replaceState") {
                    history.replaceState({}, "", message.url)
                    continue
                }

                if (message.type === "setQuery") {
                    const params = new URLSearchParams(location.search)
                    for (const key of Object.keys(message.query)) {
                        const value = message.query[key]

                        if (value != null) {
                            params.set(key, value)
                        }
                    }
                    history.replaceState({}, "", `${params.toString()}`)
                    continue   
                }

                if (message.type === "setTitle") {
                    document.title = message.title
                    continue
                }

                if (message.type === "setProp") {
                    const target = getPathItem(message.path, root)

                    if (!target) {
                        continue
                    }

                    for (const set of message.sets) {
                        applySetProp(target, set)
                    }

                    continue
                }
    
                const element = getPathItem(message.path, root)
    
                if (!element) {
                    continue
                }
    
                if (message.type === "replace") {
                    renderItem(message.item, ctx, element)
                }
                
                if (message.type === "replaceAt") {
                    renderItem(message.item, ctx, element.children.item(message.inx))
                }
                
                if (message.type === "addFront") {
                    const newEl = renderItem(message.item, ctx)
    
                    if (newEl) {
                        element.prepend(newEl)
                    }
                }
                
                if (message.type === "addBack") {
                    const newEl = renderItem(message.item, ctx)
    
                    if (newEl) {
                        element.appendChild(newEl)
                    }
                }

                if (message.type === "insertAt") {
                    const newEl = renderItem(message.item, ctx)
    
                    if (newEl) {
                        const child = element.children.item(message.inx)

                        child?.after(newEl)
                    }
                }
    
                if (message.type === "removeInx") {
                    element.children.item(message.inx)?.remove()
                }

            }
        },
        onOpen: (sender) => {
            const params = new URLSearchParams(location.href)
            const query: { [key: string]: string } = {}
            params.forEach((value, key) => {
                query[key] = value
            })
            sender.send({
                type: "pathChanged",
                path: location.pathname,
                query: query
            })

            sender.sendNow()
        }
    })

    window.addEventListener("popstate", (evet) => {
        const params = new URLSearchParams(location.href)
        const query: { [key: string]: string } = {}
        params.forEach((value, key) => {
            query[key] = value
        })
        sender.send({
            type: "pathChanged",
            path: location.pathname,
            query,
        })

        sender.sendNow()
    })        
}
</file>

<file path="wgui/src/server.rs">
#![cfg(feature = "hyper")]

use http_body_util::Full;
use hyper::body::Bytes;
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::Request;
use hyper::Response;
use hyper_util::rt::TokioIo;
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::TcpListener;
use tokio::sync::mpsc;

use crate::gui::Item;
use crate::ssr;
use crate::types::{ClientEvent, Clients};
use crate::ws::TungsteniteWs;
use crate::WguiHandle;

const INDEX_HTML_BYTES: &[u8] = include_bytes!("../../dist/index.html");
const INDEX_JS_BYTES: &[u8] = include_bytes!("../../dist/index.js");
const CSS_JS_BYTES: &[u8] = include_bytes!("../../dist/index.css");

struct Ctx {
	event_tx: mpsc::UnboundedSender<ClientEvent>,
	clients: Clients,
	ssr: Option<Arc<dyn Fn() -> Item + Send + Sync>>,
}

async fn handle_req(
	mut req: Request<hyper::body::Incoming>,
	ctx: Ctx,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
	log::info!("{} {}", req.method(), req.uri().path());

	if req.uri().path() == "/ws" && hyper_tungstenite::is_upgrade_request(&req) {
		log::info!("upgrade request");
		let (response, websocket) = hyper_tungstenite::upgrade(&mut req, None).unwrap();
		let event_tx = ctx.event_tx.clone();
		let clients = ctx.clients.clone();
		tokio::spawn(async move {
			match websocket.await {
				Ok(ws) => {
					log::info!("websocket connected");
					let ws = TungsteniteWs::new(ws);
					let handle = WguiHandle::new(event_tx, clients);
					handle.handle_ws(ws).await;
				}
				Err(err) => {
					log::error!("websocket error: {:?}", err);
				}
			}
		});
		return Ok(response);
	}

	match req.uri().path() {
		"/index.js" => Ok(Response::new(Full::new(Bytes::from(INDEX_JS_BYTES)))),
		"/index.css" => Ok(Response::new(Full::new(Bytes::from(CSS_JS_BYTES)))),
		_ => {
			if let Some(renderer) = ctx.ssr {
				let item = (renderer)();
				let html = ssr::render_document(&item);
				Ok(Response::new(Full::new(Bytes::from(html))))
			} else {
				Ok(Response::new(Full::new(Bytes::from(INDEX_HTML_BYTES))))
			}
		}
	}
}

pub struct Server {
	listener: TcpListener,
	event_tx: mpsc::UnboundedSender<ClientEvent>,
	clients: Clients,
	ssr: Option<Arc<dyn Fn() -> Item + Send + Sync>>,
}

impl Server {
	pub async fn new(
		addr: SocketAddr,
		event_tx: mpsc::UnboundedSender<ClientEvent>,
		clients: Clients,
		ssr: Option<Arc<dyn Fn() -> Item + Send + Sync>>,
	) -> Self {
		let listener = TcpListener::bind(addr).await.unwrap();
		log::info!("listening on http://localhost:{}", addr.port());

		Self {
			listener,
			event_tx,
			clients,
			ssr,
		}
	}

	pub async fn run(mut self) {
		loop {
			tokio::select! {
				res = self.listener.accept() => {
					match res {
						Ok((socket, addr)) => {
							log::info!("accepted connection from {}", addr);
							let io = TokioIo::new(socket);
							let event_tx = self.event_tx.clone();
							let clients = self.clients.clone();
							let ssr = self.ssr.clone();
							tokio::spawn(async move {
								let service = service_fn(move |req| {
									handle_req(req, Ctx {
										event_tx: event_tx.clone(),
										clients: clients.clone(),
										ssr: ssr.clone(),
									})
								});

								if let Err(err) = http1::Builder::new()
									.serve_connection(io, service)
									.with_upgrades()
									.await {

									log::error!("server error: {:?}", err);
								}
							});
						},
						Err(err) => {
							log::error!("accept error: {:?}", err);
						}
					}
				}
			}
		}
	}
}
</file>

<file path="examples/allcomponents/src/main.rs">
use log::Level;
use std::collections::HashSet;
use wgui::*;

const SELECT: u32 = 1;
const SLIDER: u32 = 2;
const TEXT_INPUT: u32 = 3;
const SHOW_TABLE_BUTTON: u32 = 4;
const TEXTAREA: u32 = 5;
const OPEN_MODAL_BUTTON: u32 = 6;
const CLOSE_MODAL_BUTTON: u32 = 7;
const MODAL_BACKDROP: u32 = 8;

#[derive(Default, Debug)]
struct State {
	option: String,
	text_input_value: String,
	slider_value: i32,
	show_table: bool,
	show_modal: bool,
}

fn render(state: &State) -> Item {
	log::info!("render state: {:?}", state);

	vstack([
		hstack([
			text("This is text1")
				.grow(2)
				.background_color("green")
				.cursor("pointer")
				.id(3),
			text("This is text2").grow(1).background_color("lightblue"),
		])
		.margin(20)
		.padding(10)
		.border("1px solid black")
		.editable(true),
		text_input() //.placeholder("Enter text here")
			.id(TEXT_INPUT)
			.width(100)
			.svalue(&state.text_input_value)
			.margin_bottom(10),
		select([
			option("Option 1", "option1"),
			option("Option 2", "option2"),
			option("Option 3", "option3"),
		])
		.id(SELECT)
		.svalue(&state.option)
		.width(100),
		slider()
			.id(SLIDER)
			.min(0)
			.max(100)
			.ivalue(state.slider_value)
			.width(100),
		textarea().placeholder("Enter text here").id(TEXTAREA),
		button("show table").id(SHOW_TABLE_BUTTON),
		button("open modal").id(OPEN_MODAL_BUTTON),
		if state.show_table {
			table([
				thead([tr([th(text("Header 1")), th(text("Header 2"))])]),
				tbody([
					tr([
						td(text("Row 1, Cell 1")).text_align("center"),
						td(text("Row 1, Cell 2")).text_align("center"),
					]),
					tr([
						td(text("Row 2, Cell 1")).text_align("center"),
						td(text("Row 2, Cell 2")).text_align("center"),
					]),
				]),
			])
		} else {
			text("Table is hidden")
		},
		modal([
			vstack([
				text("Modal heading").text_align("center"),
				text("This modal is rendered by the new component and can be dismissed from here or by clicking the backdrop."),
				hstack([
					button("close").id(CLOSE_MODAL_BUTTON),
				])
			])
			.padding(20)
			.spacing(12)
			.background_color("white")
			.width(340)
		])
		.id(MODAL_BACKDROP)
		.open(state.show_modal),
	])
	.into()
}

#[tokio::main]
async fn main() {
	simple_logger::init_with_level(Level::Info).unwrap();
	let mut wgui = Wgui::new("0.0.0.0:12346".parse().unwrap());
	let mut client_ids = HashSet::new();
	let mut state = State::default();

	while let Some(event) = wgui.next().await {
		log::info!("{:?}", event);

		match event {
			ClientEvent::Disconnected { id } => {
				client_ids.remove(&id);
			}
			ClientEvent::Connected { id } => {
				wgui.render(id, render(&state)).await;
				client_ids.insert(id);
			}
			ClientEvent::PathChanged(_) => {}
			ClientEvent::Input(q) => {}
			ClientEvent::OnClick(o) => match o.id {
				SHOW_TABLE_BUTTON => {
					state.show_table = !state.show_table;
				}
				OPEN_MODAL_BUTTON => {
					state.show_modal = true;
				}
				CLOSE_MODAL_BUTTON | MODAL_BACKDROP => {
					state.show_modal = false;
				}
				_ => {}
			},
			ClientEvent::OnTextChanged(t) => {
				if t.id == TEXT_INPUT {
					state.text_input_value = t.value;
				}
			}
			ClientEvent::OnSliderChange(s) => {
				if s.id == SLIDER {
					state.slider_value = s.value;
				}
			}
			ClientEvent::OnSelect(o) => {
				if o.id == SELECT {
					state.option = o.value;
				}
			}
			_ => {}
		}

		for id in &client_ids {
			wgui.render(*id, render(&state)).await;
		}
	}
}
</file>

<file path="wgui/src/lib.rs">
#[cfg(feature = "hyper")]
#[cfg(feature = "hyper")]
use server::Server;
use std::collections::HashMap;
#[cfg(feature = "hyper")]
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::mpsc;
use tokio::sync::RwLock;

#[cfg(feature = "axum")]
pub mod axum;
pub mod diff;
pub mod dist;
pub mod edit_distance;
pub mod gui;
#[cfg(feature = "hyper")]
mod server;
pub mod ssr;
pub mod types;
mod ui_client;
pub mod ws;
pub mod wui;

use crate::ui_client::UiWsWorker;

#[cfg(feature = "axum")]
use crate::axum::router as axum_router;
#[cfg(feature = "axum")]
use ::axum::Router;

pub use dist::*;
pub use gui::*;
pub use types::*;
#[cfg(feature = "hyper")]
pub use ws::TungsteniteWs;
pub use ws::{next_client_id, WsMessage, WsStream};

#[derive(Clone)]
pub struct WguiHandle {
	event_tx: mpsc::UnboundedSender<ClientEvent>,
	clients: Clients,
}

impl WguiHandle {
	pub(crate) fn new(event_tx: mpsc::UnboundedSender<ClientEvent>, clients: Clients) -> Self {
		Self { event_tx, clients }
	}

	pub async fn handle_ws<S>(&self, ws: S) -> usize
	where
		S: WsStream + 'static,
	{
		let id = next_client_id();
		let event_tx = self.event_tx.clone();
		let clients = self.clients.clone();
		log::info!("websocket worker created {}", id);
		tokio::spawn(async move {
			let worker = UiWsWorker::new(id, ws, event_tx, clients).await;
			worker.run().await;
		});

		id
	}

	pub async fn render(&self, client_id: usize, item: Item) {
		log::debug!("render {:?}", item);
		let clients = self.clients.read().await;
		let sender = match clients.get(&client_id) {
			Some(sender) => sender,
			None => {
				println!("client not found");
				return;
			}
		};
		sender.send(Command::Render(item)).unwrap();
	}

	pub async fn set_title(&self, client_id: usize, title: &str) {
		let clients = self.clients.read().await;
		let sender = match clients.get(&client_id) {
			Some(sender) => sender,
			None => {
				println!("client not found");
				return;
			}
		};
		sender.send(Command::SetTitle(title.to_string())).unwrap();
	}
}

pub struct Wgui {
	events_rx: mpsc::UnboundedReceiver<ClientEvent>,
	handle: WguiHandle,
}

impl Wgui {
	#[cfg(feature = "hyper")]
	pub fn new(addr: SocketAddr) -> Self {
		let (events_tx, events_rx) = mpsc::unbounded_channel();
		let clients: Clients = Arc::new(RwLock::new(HashMap::new()));

		{
			let clients = clients.clone();
			let event_tx = events_tx.clone();
			tokio::spawn(async move {
				Server::new(addr, event_tx, clients, None).await.run().await;
			});
		}

		Self {
			events_rx,
			handle: WguiHandle::new(events_tx, clients),
		}
	}

	#[cfg(feature = "hyper")]
	pub fn new_with_ssr(
		addr: SocketAddr,
		renderer: std::sync::Arc<dyn Fn() -> Item + Send + Sync>,
	) -> Self {
		let (events_tx, events_rx) = mpsc::unbounded_channel();
		let clients: Clients = Arc::new(RwLock::new(HashMap::new()));

		{
			let clients = clients.clone();
			let event_tx = events_tx.clone();
			let ssr = Some(renderer);
			tokio::spawn(async move {
				Server::new(addr, event_tx, clients, ssr).await.run().await;
			});
		}

		Self {
			events_rx,
			handle: WguiHandle::new(events_tx, clients),
		}
	}

	pub fn new_without_server() -> Self {
		let (events_tx, events_rx) = mpsc::unbounded_channel();
		let clients: Clients = Arc::new(RwLock::new(HashMap::new()));

		Self {
			events_rx,
			handle: WguiHandle::new(events_tx, clients),
		}
	}

	pub fn handle(&self) -> WguiHandle {
		self.handle.clone()
	}

	#[cfg(feature = "axum")]
	pub fn router(&self) -> Router {
		axum_router(self.handle.clone())
	}

	pub async fn next(&mut self) -> Option<ClientEvent> {
		self.events_rx.recv().await
	}

	pub async fn render(&self, client_id: usize, item: Item) {
		self.handle.render(client_id, item).await
	}

	pub async fn set_title(&self, client_id: usize, title: &str) {
		self.handle.set_title(client_id, title).await
	}
}
</file>

<file path="wgui/src/types.rs">
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::mpsc;
use tokio::sync::RwLock;

use crate::gui::Item;

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase", tag = "type")]
pub struct OnClick {
	pub id: u32,
	pub inx: Option<u32>,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct OnKeyDown {
	pub id: Option<String>,
	pub keycode: String,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct OnTextChanged {
	pub id: u32,
	pub inx: Option<u32>,
	pub value: String,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct PathChanged {
	pub path: String,
	pub query: HashMap<String, String>,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct InputQuery {}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct OnSliderChange {
	pub id: u32,
	pub inx: Option<u32>,
	pub value: i32,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct OnSelect {
	pub id: u32,
	pub inx: Option<u32>,
	pub value: String,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase", tag = "type")]
pub enum ClientEvent {
	Disconnected { id: usize },
	Connected { id: usize },
	PathChanged(PathChanged),
	Input(InputQuery),
	OnClick(OnClick),
	OnTextChanged(OnTextChanged),
	OnSliderChange(OnSliderChange),
	OnSelect(OnSelect),
}

pub type ItemPath = Vec<usize>;

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct Replace {
	pub path: ItemPath,
	pub item: Item,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct ReplaceAt {
	pub path: ItemPath,
	pub item: Item,
	pub inx: usize,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct AddBack {
	pub path: ItemPath,
	pub item: Item,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct AddFront {
	pub path: ItemPath,
	pub item: Item,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct InsertAt {
	pub path: ItemPath,
	pub item: Item,
	pub inx: usize,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct RemoveInx {
	pub path: ItemPath,
	pub inx: usize,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct PushState {
	pub url: String,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct ReplaceState {
	pub url: String,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct SetQuery {
	pub query: HashMap<String, String>,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub enum Value {
	String(String),
	Number(u32),
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub enum PropKey {
	ID = 1,
	Border = 2,
	BackgroundColor = 3,
	Spacing = 4,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct SetProp {
	pub key: PropKey,
	pub value: Value,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase", tag = "type")]
pub enum ClientAction {
	Replace(Replace),
	ReplaceAt(ReplaceAt),
	AddBack(AddBack),
	AddFront(AddFront),
	InsertAt(InsertAt),
	RemoveInx(RemoveInx),
	PushState(PushState),
	ReplaceState(ReplaceState),
	SetQuery(SetQuery),
	SetProp { path: ItemPath, sets: Vec<SetProp> },
	SetTitle { title: String },
}

pub enum ServerEvent {
	Connected {
		ch: mpsc::UnboundedSender<ClientEvent>,
	},
	ClientEvent {
		id: usize,
		event: ClientEvent,
	},
}

#[derive(Debug, Clone)]
pub enum Command {
	Render(Item),
	SetTitle(String),
}

pub type Clients = Arc<RwLock<HashMap<usize, mpsc::UnboundedSender<Command>>>>;
</file>

<file path="examples/todo/src/main.rs">
use log::Level;
use std::collections::HashSet;
use std::vec;
use wgui::*;

struct TodoItems {
	name: String,
	completed: bool,
}

struct TodoState {
	new_todo_name: String,
	slider_value: i32,
	items: Vec<TodoItems>,
}

fn get_color(completed: bool) -> String {
	if completed {
		"#d3d3d3".to_string()
	} else {
		"#ffffff".to_string()
	}
}

const ADD_TODO_ID: u32 = 1;
const TODO_CHECKBOX_ID: u32 = 2;
const NEW_TODO_TEXT_ID: u32 = 3;

fn render(state: &TodoState) -> Item {
	vstack([
		text("Todo List"),
		vstack([
			hstack([
				text_input()
					.id(NEW_TODO_TEXT_ID)
					.placeholder("What needs to be done?")
					.svalue(&state.new_todo_name),
				button("Add").id(ADD_TODO_ID),
			])
			.spacing(3),
			vstack(state.items.iter().enumerate().map(|(i, item)| {
				hstack([
					text(&item.name),
					checkbox()
						.id(TODO_CHECKBOX_ID)
						.inx(i as u32)
						.checked(item.completed),
				])
				.border(&format!("1px solid {}", get_color(item.completed)))
				.background_color(&get_color(item.completed))
				.padding(10)
				.margin(5)
			}))
			.spacing(5),
		]),
	])
}

#[tokio::main]
async fn main() {
	simple_logger::init_with_level(Level::Info).unwrap();

	let mut state = TodoState {
		new_todo_name: "".to_string(),
		slider_value: 0,
		items: vec![],
	};

	let mut client_ids = HashSet::new();

	let mut wgui = Wgui::new("0.0.0.0:12345".parse().unwrap());

	while let Some(event) = wgui.next().await {
		log::info!("{:?}", event);

		match event {
			ClientEvent::Disconnected { id } => {
				client_ids.remove(&id);
			}
			ClientEvent::Connected { id } => {
				wgui.render(id, render(&state)).await;
				client_ids.insert(id);
			}
			ClientEvent::PathChanged(_) => {}
			ClientEvent::Input(q) => {}
			ClientEvent::OnClick(o) => match o.id {
				ADD_TODO_ID => {
					log::info!("add_todo_button clicked");
					state.items.push(TodoItems {
						name: state.new_todo_name.clone(),
						completed: false,
					});
					state.new_todo_name = "".to_string();
				}
				TODO_CHECKBOX_ID => {
					if let Some(inx) = o.inx {
						log::info!("todo_checkbox_{} clicked", inx);
						state.items[inx as usize].completed = !state.items[inx as usize].completed;
					}
				}
				_ => {}
			},
			ClientEvent::OnTextChanged(t) => match t.id {
				NEW_TODO_TEXT_ID => {
					log::info!("new_todo_name {:?}", t.value);
					state.new_todo_name = t.value;
				}
				_ => {}
			},
			ClientEvent::OnSliderChange(s) => {
				state.slider_value = s.value;
			}
			_ => {}
		}

		let done = state.items.iter().filter(|item| item.completed).count();
		let undone = state.items.len() - done;
		let title = format!("Todo {} done / {} undone", done, undone);

		for id in &client_ids {
			wgui.set_title(*id, &title).await;
			wgui.render(*id, render(&state)).await;
		}
	}
}
</file>

<file path="ts/types.ts">
import { Deboncer } from "./debouncer.ts";
import { MessageSender } from "./message_sender.ts";

export type Text = {
    type: "text"
    value: string
	placeholder?: string
}

export enum FlexDirection {
    Row = "row",
    Column = "column"
}

export type Flex = {
    grow: number
    flexDirection: FlexDirection
}

export type Pos = {
	x: number
	y: number
}

export type Layout = {
    type: "layout"
    flex?: FlexDirection
    height: number
    width: number
    marginTop?: number
    marginRight?: number
    marginBottom?: number
    marginLeft?: number
    margin?: number 
    paddingTop?: number
    paddingRight?: number
    paddingBottom?: number
    paddingLeft?: number
    padding?: number
	spacing?: number
	border?: string
	backgroundColor?: string
	cursor?: string
	wrap?: boolean
	maxWidth?: number
	pos?: Pos
	vresize?: boolean
	hresize?: boolean
    body: Item[]
}

export type Button = {
    type: "button"
    title: string
}

export type TextInput = {
    type: "textInput"
    placeholder: string
    value: string
}

export type Textarea = {
	type: "textarea"
	value: string
	placeholder: string
}

export type Checkbox = {
    type: "checkbox"
    checked: boolean
}

export type Title = {
	type: "title"
	title: string
}

export type Slider = {
	type: "slider"
	min: number
	max: number
	value: number
	step: number
}

export type Select = {
	type: "select"
	value: string
	options: {
		value: string
		name: string
	}[]
}

export type Table = {
	type: "table"
	items: Item[]
}

export type Thead = {
	type: "thead"
	items: Item[]
}

export type Tbody = {
	type: "tbody"
	items: Item[]
}

export type Tr = {
	type: "tr"
	items: Item[]
}

export type Th = {
	type: "th"
	item: Item
}

export type Td = {
	type: "td"
	item: Item
}

export type FolderPicker = {
	type: "folderPicker"
}

export type FloatingLayout = {
	type: "flaotingLayout"
	x: number
	y: number
	width: number
	height: number
}

export type Modal = {
	type: "modal"
	open: boolean
	body: Item[]
}

export type None = {
	type: "none"
}

export type Image = {
    type: "img"
    src: string
    alt?: string
    objectFit?: string
}

export type ItemPayload = Text |
 	TextInput |
 	Textarea |
 	Table |
 	Thead |
 	Tbody |
 	Tr |
 	Th | 
 	Td |
 	Select | 
 	Checkbox | 
 	Slider |
 	Layout |
 	Button |
 	Image |
 	FolderPicker |
 	FloatingLayout |
 	Modal |
 	None 

export type Item = {
	id: number
	inx?: number
	typ: number
	height: number
	width: number
	minHeight: number
	maxHeight: number
	minWidth: number
	maxWidth: number
	grow?: number
	backgroundColor?: string
	textAlign?: string
	cursor?: string
	margin?: number
	padding?: number
	border?: string
	marginLeft?: number
	marginRight?: number
	marginTop?: number
	marginBottom?: number
	paddingLeft?: number
	paddingRight?: number
	paddingTop?: number
	paddingBottom?: number
	editable?: boolean
	overflow?: string
	payload: ItemPayload
}

export type Replace = {
    type: "replace"
    path: number[]
    item: Item
}

export type ReplaceAt = {
    type: "replaceAt"
    inx: number
    path: number[]
    item: Item
}

export type AddBack = {
    type: "addBack"
    path: number[]
    item: Item
}

export type AddFront = {
    type: "addFront"
    path: number[]
    item: Item
}

export type InsertAt = {
    type: "insertAt"
    inx: number
    item: Item
    path: number[]
}

export type RemoveInx = {
    type: "removeInx"
    inx: number
    path: number[]
}

export type PropKey = "ID" | "Border" | "BackgroundColor" | "Spacing"

export type PropValue = {
    String?: string
    Number?: number
}

export type SetPropSet = {
    key: PropKey
    value: PropValue
}

export type PushState = {
    type: "pushState"
    url: string
}

export type ReplaceState = {
    type: "replaceState"
    url: string
}

export type SetQuery = {
    type: "setQuery"
    query: {
        [key: string]: string
    }
}

export type SetProp = {
    type: "setProp"
    path: number[]
    sets: SetPropSet[]
}

export type SetTitle = {
    type: "setTitle"
    title: string
}

export type SrvMessage = Replace |
    ReplaceAt |
    AddBack | 
    AddFront | 
    InsertAt | 
    RemoveInx |
    PushState |
    ReplaceState |
    SetQuery |
    SetProp |
    SetTitle

export type OnClick = {
    type: "onClick"
    id: number
	inx?: number
}

export type OnTextChange = {
    type: "onTextChanged"
    id: number
	inx?: number
    value: string
}

export type OnKeyDown = {
    type: "onKeyDown"
    id: string
    name: string
    keycode: string
}

export type PathChanged = {
    type: "pathChanged"
    path: string
    query: {
        [key: string]: string
    }
}

export type OnSliderChange = {
	type: "onSliderChange"
	id: number
	inx?: number
	value: number
}

export type OnSelect = {
	type: "onSelect"
	id: number
	inx?: number
	value: string
}

export type MessageToSrv = OnClick | 
    OnTextChange | 
    OnKeyDown | 
    PathChanged |
	OnSliderChange |
	OnSelect

export type MessagesToSrv = MessageToSrv[]

export type Context = {
    debouncer: Deboncer
    sender: MessageSender
}
</file>

<file path="ts/render.ts">
import { Context, Item, ItemPayload } from "./types.ts";



const renderChildren = (element: HTMLElement, items: Item[], ctx: Context) => {
	for (const item of items) {
		const child = renderItem(item, ctx)
		if (child) {
			element.appendChild(child)
		}
	}
}

const renderPayload = (item: Item, ctx: Context, old?: Element | null) => {
	const payload = item.payload
	if (payload.type === "checkbox") {
		let checkbox: HTMLInputElement
		if (old instanceof HTMLInputElement) {
			checkbox = old
		} else {
			checkbox = document.createElement("input")
			if (old) old.replaceWith(checkbox)
		}
		checkbox.type = "checkbox"
		checkbox.checked = payload.checked
		checkbox.classList.add("retro-checkbox")
		if (item.id) {
			checkbox.onclick = () => {
				ctx.sender.send({
					type: "onClick",
					id: item.id,
					inx: item.inx,
				})
				ctx.sender.sendNow()
			}
		}
		return checkbox
	}

	if (payload.type === "layout") {
		let element: HTMLDivElement
		if (old instanceof HTMLDivElement) {
			element = old
			old.innerHTML = ""
			for (const i of payload.body) {
				const el = renderItem(i, ctx)
				if (el) {
					old.appendChild(el as any)
				}
			}
		} else {
			const div = document.createElement("div")
			for (const i of payload.body) {
				const el = renderItem(i, ctx)
				if (el) {
					div.appendChild(el as any)
				}
			}
			element = div
			if (old) old.replaceWith(element)
		}
		
		element.classList.add("retro-panel")

		if (payload.spacing) {
			element.style.gap = payload.spacing + "px"
		}
		if (payload.wrap) {
			element.classList.add("flex-wrap")
		}
		if (payload.flex) {
			element.style.display = "flex"
			element.style.flexDirection = payload.flex
			element.classList.add(payload.flex === "row" ? "flex-row" : "flex-col")
		}
		return element
	}

	if (payload.type === "select") {
		let select: HTMLSelectElement
		if (old instanceof HTMLSelectElement) {
			select = old
			// Use slice for broad compatibility instead of Array.from
			const existingOptions = Array.prototype.slice.call(old.options) as HTMLOptionElement[]
			const newOptions = payload.options.map(option => option.value)
	
			// Update the options only if they differ
			if (existingOptions.length !== payload.options.length || !existingOptions.every((opt, index) => opt.value === newOptions[index])) {
				old.innerHTML = ""
				for (const option of payload.options) {
					const opt = document.createElement("option")
					opt.value = option.value
					opt.text = option.name
					old.add(opt)
				}
			}
		} else {
			select = document.createElement("select")
			for (const option of payload.options) {
				const opt = document.createElement("option")
				opt.value = option.value
				opt.text = option.name
				select.add(opt)
			}
			select.value = payload.value
			if (old) old.replaceWith(select)
		}

		select.classList.add("retro-input")
		select.oninput = (e: any) => {
			ctx.sender.send({
				type: "onSelect",
				id: item.id,
				inx: item.inx,
				value: e.target.value
			})
			ctx.sender.sendNow()
		}

		return select
	}

	if (payload.type === "button") {
		let button: HTMLButtonElement
		if (old instanceof HTMLButtonElement) {
			button = old
		} else {
			button = document.createElement("button")
			if (old) old.replaceWith(button)
		}
		button.textContent = payload.title
		button.classList.add("retro-button")
		if (item.id) {
			button.onclick = () => {
				ctx.sender.send({
					type: "onClick",
					id: item.id,
					inx: item.inx,
				})
				ctx.sender.sendNow()
			}
		}
		return button
	}

	if (payload.type === "img") {
		let image: HTMLImageElement
		if (old instanceof HTMLImageElement) {
			image = old
		} else {
			image = document.createElement("img")
			if (old) old.replaceWith(image)
		}
		image.src = payload.src
		image.alt = payload.alt ?? ""
		image.style.maxWidth = "100%"
		image.style.maxHeight = "100%"
		image.style.objectFit = payload.objectFit ?? "contain"
		image.loading = "lazy"
		image.classList.add("retro-panel")
		return image
	}

	if (payload.type === "slider") {
		let slider: HTMLInputElement
		if (old instanceof HTMLInputElement) {
			slider = old
		} else {
			slider = document.createElement("input")
			if (old) old.replaceWith(slider)
		}
		slider.min = payload.min.toString()
		slider.max = payload.max.toString()
		slider.type = "range"
		slider.value = payload.value.toString()
		slider.step = payload.step.toString()
		slider.classList.add("retro-input")
		if (item.id) {
			slider.oninput = (e: any) => {
				ctx.sender.send({
					type: "onSliderChange",
					id: item.id,
					inx: item.inx,
					value: parseInt(e.target.value)
				})
				ctx.sender.sendNow()
			}
		}
		return slider
	}

	if (payload.type === "textInput") {
		let input: HTMLInputElement
		if (old instanceof HTMLInputElement) {
			input = old
		} else {
			input = document.createElement("input")
			if (old) old.replaceWith(input)
		}
		input.placeholder = payload.placeholder as string
		input.value = payload.value
		input.classList.add("retro-input")
		if (item.id) {
			input.oninput = (e: any) => {
				ctx.sender.send({
					type: "onTextChanged",
					id: item.id,
					inx: item.inx,
					value: e.target.value,
				})
			}
		}

		return input
	}

	if (payload.type === "textarea") {
		let textarea: HTMLTextAreaElement
		if (old instanceof HTMLTextAreaElement) {
			textarea = old
		} else {
			textarea = document.createElement("textarea")
			if (old) old.replaceWith(textarea)
		}
		textarea.placeholder = payload.placeholder as string
		textarea.wrap = "off"
		textarea.style.resize = "none"
		textarea.style.overflowY = "hidden"
		textarea.style.minHeight = "20px"
		textarea.style.lineHeight = "20px"
		textarea.value = payload.value
		const rowCount = payload.value.split("\n").length
		textarea.style.height = rowCount * 20 + "px"
		textarea.classList.add("retro-input")
		textarea.oninput = (e: any) => {
			const value = e.target.value
			const rowCount = value.split("\n").length
			textarea.style.height = (rowCount + 1) * 20 + "px"

			if (item.id) {
				ctx.sender.send({
					type: "onTextChanged",
					id: item.id,
					inx: item.inx,
					value: e.target.value,
				})
			}
		}
		return textarea
	}

	if (payload.type === "table") {
		let table: HTMLTableElement
		if (old instanceof HTMLTableElement) {
			table = old
		} else {
			table = document.createElement("table")
			if (old) old.replaceWith(table)
		}
		table.classList.add("retro-table")
		renderChildren(table, payload.items, ctx)
		return table
	}

	if (payload.type === "thead") {
		let thead: HTMLTableSectionElement
		if (old instanceof HTMLTableSectionElement) {
			thead = old
		} else {
			thead = document.createElement("thead")
			if (old) old.replaceWith(thead)
		}
		renderChildren(thead, payload.items, ctx)
		return thead
	}

	if (payload.type === "tbody") {
		let tbody: HTMLTableSectionElement
		if (old instanceof HTMLTableSectionElement) {
			tbody = old
		} else {
			tbody = document.createElement("tbody")
			if (old) old.replaceWith(tbody)
		}
		renderChildren(tbody, payload.items, ctx)
		return tbody
	}

	if (payload.type === "tr") {
		let tr: HTMLTableRowElement
		if (old instanceof HTMLTableRowElement) {
			tr = old
		} else {
			tr = document.createElement("tr")
			if (old) old.replaceWith(tr)
		}
		renderChildren(tr, payload.items, ctx)
		return tr
	}

	if (payload.type === "th") {
		let th: HTMLTableCellElement
		if (old instanceof HTMLTableCellElement) {
			th = old
		} else {
			th = document.createElement("th")
			if (old) old.replaceWith(th)
		}
		renderChildren(th, [payload.item], ctx)
		return th
	}

	if (payload.type === "td") {
		let td: HTMLTableCellElement
		if (old instanceof HTMLTableCellElement) {
			td = old
		} else {
			td = document.createElement("td")
			if (old) old.replaceWith(td)
		}
		renderChildren(td, [payload.item], ctx)
		return td
	}

	if (payload.type === "text") {
		let element: HTMLSpanElement
		if (old instanceof HTMLSpanElement) {
			element = old
			element.innerText = payload.value + ""
		} else {
			element = document.createElement("span")
			element.innerText = payload.value + ""
			if (old) old.replaceWith(element)
		}
		element.classList.add("retro-text")
		if (item.id) {
			element.onclick = () => {
				ctx.sender.send({
					type: "onClick",
					id: item.id,
					inx: item.inx,
				})
				ctx.sender.sendNow()
			}
			element.classList.add("retro-clickable")
		}
		return element
	}

	if (payload.type === "folderPicker") {
		let element: HTMLInputElement
		if (old instanceof HTMLInputElement) {
			element = old
		} else {
			element = document.createElement("input")
			if (old) old.replaceWith(element)
		}
		element.type = "file"
		element.webkitdirectory = true
		// element.multiple = true
		element.oninput = (e: any) => {
			console.log("oninput", e)
		}
		return element
	}

	if (payload.type === "modal") {
		let overlay: HTMLDivElement
		if (old instanceof HTMLDivElement && old.dataset.modal === "overlay") {
			overlay = old
			overlay.innerHTML = ""
		} else {
			overlay = document.createElement("div")
			overlay.dataset.modal = "overlay"
			overlay.setAttribute("role", "dialog")
			overlay.setAttribute("aria-modal", "true")
			if (old) old.replaceWith(overlay)
		}

		overlay.style.position = "fixed"
		overlay.style.left = "0"
		overlay.style.top = "0"
		overlay.style.width = "100vw"
		overlay.style.height = "100vh"
		overlay.style.display = payload.open ? "flex" : "none"
		overlay.style.alignItems = "center"
		overlay.style.justifyContent = "center"
		overlay.style.padding = "32px"
		overlay.style.boxSizing = "border-box"
		overlay.style.backgroundColor = "rgba(0, 0, 0, 0.45)"
		overlay.style.backdropFilter = "blur(2px)"
		overlay.style.zIndex = "1000"
		overlay.style.pointerEvents = payload.open ? "auto" : "none"
		overlay.setAttribute("aria-hidden", payload.open ? "false" : "true")

		renderChildren(overlay, payload.body, ctx)

		if (item.id) {
			overlay.onclick = (event: MouseEvent) => {
				if (event.target === overlay) {
					ctx.sender.send({
						type: "onClick",
						id: item.id,
						inx: item.inx,
					})
					ctx.sender.sendNow()
				}
			}
		} else {
			overlay.onclick = null
		}

		return overlay
	}

	if (payload.type === "flaotingLayout") {
		let element: HTMLDivElement
		if (old instanceof HTMLDivElement) {
			element = old
		} else {
			element = document.createElement("div")
			if (old) old.replaceWith(element)
		}
		element.style.position = "absolute"
		element.style.left = payload.x + "px"
		element.style.top = payload.y + "px"
		element.style.width = payload.width + "px"
		element.style.height = payload.height + "px"
		return element
	}
}

export const renderItem = (item: Item, ctx: Context, old?: Element | null) => {
	const element = renderPayload(item, ctx, old)

	if (!element) {
		return
	}

	if (item.width) {
		element.style.width = item.width + "px"
	}
	if (item.height) {
		element.style.height = item.height + "px"
	}
	if (item.minWidth) element.style.minWidth = item.minWidth + "px"
	if (item.maxWidth) {
		element.style.maxWidth = item.maxWidth + "px"
	}
	if (item.minHeight) element.style.minHeight = item.minHeight + "px"
	if (item.maxHeight) {
		element.style.maxHeight = item.maxHeight + "px"
	}
	if (item.grow) {
		element.style.flexGrow = item.grow.toString()
		element.classList.add("grow")
	}
	if (item.backgroundColor) {
		element.style.backgroundColor = item.backgroundColor
	}
	if (item.textAlign) {
		element.style.textAlign = item.textAlign
	}
	if (item.cursor) {
		element.style.cursor = item.cursor
	}
	if (item.margin) {
		element.style.margin = item.margin + "px"
	}
	if (item.marginLeft) {
		element.style.marginLeft = item.marginLeft + "px"
	}
	if (item.marginRight) {
		element.style.marginRight = item.marginRight + "px"
	}
	if (item.marginTop) {
		element.style.marginTop = item.marginTop + "px"
	}
	if (item.marginBottom) {
		element.style.marginBottom = item.marginBottom + "px"
	}
	if (item.padding) {
		element.style.padding = item.padding + "px"
	}
	if (item.paddingLeft) {
		element.style.paddingLeft = item.paddingLeft + "px"
	}
	if (item.paddingRight) {
		element.style.paddingRight = item.paddingRight + "px"
	}
	if (item.paddingTop) {
		element.style.paddingTop = item.paddingTop + "px"
	}
	if (item.paddingBottom) {
		element.style.paddingBottom = item.paddingBottom + "px"
	}
	if (item.border) {
		element.style.border = item.border
	}
	if (item.editable) {
		element.contentEditable = "true"
	}
	if (item.overflow) element.style.overflow = item.overflow
	return element
}
</file>

<file path="wgui/src/gui.rs">
#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum FlexDirection {
	Column,
	Row,
}

impl Default for FlexDirection {
	fn default() -> Self {
		FlexDirection::Column
	}
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
enum Value {
	String(String),
	Bool(bool),
	Undefined,
}

impl Default for Value {
	fn default() -> Self {
		Value::Undefined
	}
}

#[derive(Debug, PartialEq, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct Pos {
	x: u32,
	y: u32,
}

#[derive(Debug, PartialEq, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct Layout {
	pub body: Vec<Item>,
	pub flex: FlexDirection,
	pub spacing: u32,
	pub wrap: bool,
	pub horizontal_resize: bool,
	pub vresize: bool,
	pub hresize: bool,
	pub pos: Option<Pos>,
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ItemPayload {
	Layout(Layout),
	Text {
		value: String,
	},
	TextInput {
		value: String,
		placeholder: String,
	},
	Textarea {
		value: String,
		placeholder: String,
	},
	Select {
		value: String,
		options: Vec<SelectOption>,
	},
	Checkbox {
		checked: bool,
	},
	Slider {
		min: i32,
		max: i32,
		value: i32,
		step: i32,
	},
	Button {
		title: String,
	},
	Table {
		items: Vec<Item>,
	},
	Tbody {
		items: Vec<Item>,
	},
	Thead {
		items: Vec<Item>,
	},
	Tr {
		items: Vec<Item>,
	},
	Th {
		item: Box<Item>,
	},
	Td {
		item: Box<Item>,
	},
	Img {
		src: String,
		alt: String,
		object_fit: Option<String>,
	},
	FolderPicker,
	FloatingLayout {
		x: u32,
		y: u32,
		width: u32,
		height: u32,
	},
	Modal {
		body: Vec<Item>,
		open: bool,
	},
	None,
}

impl Default for ItemPayload {
	fn default() -> Self {
		ItemPayload::None
	}
}

#[derive(Debug, PartialEq, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Item {
	pub id: u32,
	pub inx: u32,
	pub payload: ItemPayload,
	pub border: String,
	pub background_color: String,
	pub cursor: String,
	pub height: u32,
	pub width: u32,
	pub min_height: u32,
	pub max_height: u32,
	pub min_width: u32,
	pub max_width: u32,
	pub grow: u32,
	pub text_align: String,
	pub margin: u16,
	pub margin_left: u16,
	pub margin_right: u16,
	pub margin_top: u16,
	pub margin_bottom: u16,
	pub padding: u16,
	pub padding_left: u16,
	pub padding_right: u16,
	pub padding_top: u16,
	pub padding_bottom: u16,
	pub overflow: String,
	pub editable: bool,
}

pub fn checkbox() -> Item {
	Item {
		payload: ItemPayload::Checkbox { checked: false },
		..Default::default()
	}
}

pub fn vstack<I>(body: I) -> Item
where
	I: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Layout(Layout {
			body: body.into_iter().collect(),
			flex: FlexDirection::Column,
			..Default::default()
		}),
		..Default::default()
	}
}

pub fn hstack<I>(body: I) -> Item
where
	I: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Layout(Layout {
			body: body.into_iter().collect(),
			flex: FlexDirection::Row,
			..Default::default()
		}),
		..Default::default()
	}
}

pub fn button(title: &str) -> Item {
	Item {
		payload: ItemPayload::Button {
			title: title.to_string(),
		},
		..Default::default()
	}
}

pub fn text(text: &str) -> Item {
	Item {
		payload: ItemPayload::Text {
			value: text.to_string(),
		},
		..Default::default()
	}
}

pub fn text_input() -> Item {
	Item {
		payload: ItemPayload::TextInput {
			value: "".to_string(),
			placeholder: "".to_string(),
		},
		..Default::default()
	}
}

pub fn textarea() -> Item {
	Item {
		payload: ItemPayload::Textarea {
			value: "".to_string(),
			placeholder: "".to_string(),
		},
		..Default::default()
	}
}

pub fn modal<I>(body: I) -> Item
where
	I: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Modal {
			body: body.into_iter().collect(),
			open: true,
		},
		..Default::default()
	}
}

#[derive(Debug, PartialEq, Clone, serde::Serialize, serde::Deserialize)]
pub struct SelectOption {
	value: String,
	name: String,
}

pub fn option(value: &str, name: &str) -> SelectOption {
	SelectOption {
		value: value.to_string(),
		name: name.to_string(),
	}
}

impl SelectOption {
	pub fn value(&self) -> &str {
		&self.value
	}

	pub fn name(&self) -> &str {
		&self.name
	}
}

pub fn select<I>(options: I) -> Item
where
	I: IntoIterator<Item = SelectOption>,
{
	Item {
		payload: ItemPayload::Select {
			value: "".to_string(),
			options: options.into_iter().collect(),
		},
		..Default::default()
	}
}

pub fn slider() -> Item {
	Item {
		payload: ItemPayload::Slider {
			min: 0,
			max: 100,
			value: 0,
			step: 1,
		},
		..Default::default()
	}
}

pub fn table<T>(body: T) -> Item
where
	T: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Table {
			items: body.into_iter().collect(),
		},
		..Default::default()
	}
}

pub fn thead<T>(items: T) -> Item
where
	T: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Thead {
			items: items.into_iter().collect(),
		},
		..Default::default()
	}
}

pub fn tbody<T>(items: T) -> Item
where
	T: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Tbody {
			items: items.into_iter().collect(),
		},
		..Default::default()
	}
}

pub fn tr<T>(items: T) -> Item
where
	T: IntoIterator<Item = Item>,
{
	Item {
		payload: ItemPayload::Tr {
			items: items.into_iter().collect(),
		},
		..Default::default()
	}
}

pub fn th(item: Item) -> Item {
	Item {
		payload: ItemPayload::Th {
			item: Box::new(item),
		},
		..Default::default()
	}
}

pub fn td(items: Item) -> Item {
	Item {
		payload: ItemPayload::Td {
			item: Box::new(items),
		},
		..Default::default()
	}
}

pub fn img(src: &str, alt: &str) -> Item {
	Item {
		payload: ItemPayload::Img {
			src: src.to_string(),
			alt: alt.to_string(),
			object_fit: None,
		},
		..Default::default()
	}
}

pub fn folder_picker() -> Item {
	Item {
		payload: ItemPayload::FolderPicker,
		..Default::default()
	}
}

impl Item {
	pub fn id(mut self, id: u32) -> Self {
		self.id = id;
		self
	}

	pub fn inx(mut self, inx: u32) -> Self {
		self.inx = inx;
		self
	}

	pub fn checked(mut self, checked: bool) -> Self {
		self.payload = ItemPayload::Checkbox { checked };
		self
	}

	pub fn min(mut self, m: i32) -> Self {
		match self.payload {
			ItemPayload::Slider { ref mut min, .. } => {
				*min = m;
			}
			_ => {}
		}
		self
	}

	pub fn max(mut self, m: i32) -> Self {
		match self.payload {
			ItemPayload::Slider { ref mut max, .. } => {
				*max = m;
			}
			_ => {}
		}
		self
	}

	pub fn ivalue(mut self, v: i32) -> Self {
		match self.payload {
			ItemPayload::Slider { ref mut value, .. } => {
				*value = v;
			}
			_ => {}
		}
		self
	}

	pub fn svalue(mut self, v: &str) -> Self {
		match self.payload {
			ItemPayload::Text { ref mut value, .. } => {
				*value = v.to_string();
			}
			ItemPayload::TextInput { ref mut value, .. } => {
				*value = v.to_string();
			}
			ItemPayload::Textarea { ref mut value, .. } => {
				*value = v.to_string();
			}
			ItemPayload::Select { ref mut value, .. } => {
				*value = v.to_string();
			}
			_ => {}
		}
		self
	}

	pub fn step(mut self, s: i32) -> Self {
		match self.payload {
			ItemPayload::Slider { ref mut step, .. } => {
				*step = s;
			}
			_ => {}
		}
		self
	}

	pub fn spacing(mut self, spacing: u32) -> Self {
		match self.payload {
			ItemPayload::Layout(ref mut layout) => {
				layout.spacing = spacing;
			}
			_ => {}
		}
		self
	}

	pub fn padding(mut self, padding: u16) -> Self {
		self.padding = padding;
		self
	}

	pub fn padding_left(mut self, padding_left: u16) -> Self {
		self.padding_left = padding_left;
		self
	}

	pub fn padding_right(mut self, padding_right: u16) -> Self {
		self.padding_right = padding_right;
		self
	}

	pub fn padding_top(mut self, padding_top: u16) -> Self {
		self.padding_top = padding_top;
		self
	}

	pub fn padding_bottom(mut self, padding_bottom: u16) -> Self {
		self.padding_bottom = padding_bottom;
		self
	}

	pub fn margin(mut self, margin: u16) -> Self {
		self.margin = margin;
		self
	}

	pub fn margin_left(mut self, margin_left: u16) -> Self {
		self.margin_left = margin_left;
		self
	}

	pub fn margin_right(mut self, margin_right: u16) -> Self {
		self.margin_right = margin_right;
		self
	}

	pub fn margin_top(mut self, margin_top: u16) -> Self {
		self.margin_top = margin_top;
		self
	}

	pub fn margin_bottom(mut self, margin_bottom: u16) -> Self {
		self.margin_bottom = margin_bottom;
		self
	}

	pub fn placeholder(mut self, p: &str) -> Self {
		match self.payload {
			ItemPayload::TextInput {
				ref mut placeholder,
				..
			} => {
				*placeholder = p.to_string();
			}
			ItemPayload::Textarea {
				ref mut placeholder,
				..
			} => {
				*placeholder = p.to_string();
			}
			_ => {}
		}
		self
	}

	pub fn border(mut self, b: &str) -> Self {
		self.border = b.to_string();
		self
	}

	pub fn background_color(mut self, c: &str) -> Self {
		self.background_color = c.to_string();
		self
	}

	pub fn width(mut self, w: u32) -> Self {
		self.width = w;
		self
	}

	pub fn min_width(mut self, w: u32) -> Self {
		self.min_width = w;
		self
	}

	pub fn max_width(mut self, w: u32) -> Self {
		self.max_width = w;
		self
	}

	pub fn grow(mut self, g: u32) -> Self {
		self.grow = g;
		self
	}

	pub fn text_align(mut self, a: &str) -> Self {
		self.text_align = a.to_string();
		self
	}

	pub fn cursor(mut self, c: &str) -> Self {
		self.cursor = c.to_string();
		self
	}

	pub fn height(mut self, h: u32) -> Self {
		self.height = h;
		self
	}

	pub fn min_height(mut self, h: u32) -> Self {
		self.min_height = h;
		self
	}

	pub fn max_height(mut self, h: u32) -> Self {
		self.max_height = h;
		self
	}

	pub fn wrap(mut self, w: bool) -> Self {
		match self.payload {
			ItemPayload::Layout(ref mut layout) => {
				layout.wrap = w;
			}
			_ => {}
		}
		self
	}

	pub fn object_fit(mut self, fit: &str) -> Self {
		match self.payload {
			ItemPayload::Img {
				ref mut object_fit, ..
			} => {
				*object_fit = Some(fit.to_string());
			}
			_ => {}
		}
		self
	}

	pub fn editable(mut self, e: bool) -> Self {
		self.editable = e;
		self
	}

	pub fn overflow(mut self, o: &str) -> Self {
		self.overflow = o.to_string();
		self
	}

	pub fn open(mut self, open: bool) -> Self {
		if let ItemPayload::Modal {
			open: ref mut is_open,
			..
		} = self.payload
		{
			*is_open = open;
		}
		self
	}

	pub fn hresize(mut self, r: bool) -> Self {
		match self.payload {
			ItemPayload::Layout(ref mut layout) => {
				layout.horizontal_resize = r;
			}
			_ => {}
		}
		self
	}

	pub fn vresize(mut self, r: bool) -> Self {
		match self.payload {
			ItemPayload::Layout(ref mut layout) => {
				layout.vresize = r;
			}
			_ => {}
		}
		self
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_vstack() {
		let view = vstack([hstack([text("Hello"), button("Click me")]), button("DUNNO")]);
	}
}
</file>

</files>
